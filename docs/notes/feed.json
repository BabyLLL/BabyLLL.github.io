{
    "version": "https://jsonfeed.org/version/1",
    "title": "Anthony Fu's Notes",
    "home_page_url": "https://antfu.me/notes",
    "feed_url": "https://antfu.me/notes/feed.json",
    "description": "Anthony Fu's Notes",
    "icon": "https://antfu.me/avatar.png",
    "author": {
        "name": "Anthony Fu",
        "url": "https://antfu.me"
    },
    "items": [
        {
            "content_html": "<p>When you want to get the real file path of a certain package, you could use <code>require.resolve</code> to fetch the their main entry path.</p>\n<pre><code class=\"language-bash\">&gt; require.resolve('vite')\n'/Users/.../node_modules/vite/dist/node/index.js'\n\n&gt; require.resolve('windicss')\n'/Users/.../node_modules/windicss/index.js'\n</code></pre>\n<p>However, when you want to get the root directory of the package, you will find the result of <code>require.resolve</code> could vary based on different packages' configuration.</p>\n<p>A trick for this is to resolve the <code>package.json</code> instead, as the <code>package.json</code> is always located at the root of the package. Combining with <code>path.dirname</code>, you could always get the package root.</p>\n<pre><code class=\"language-bash\">&gt; path.dirname(require.resolve('vite/package.json'))\n'/Users/.../node_modules/vite'\n</code></pre>\n",
            "url": "https://antfu.me/notes#get-package-root",
            "title": "Get Package Root",
            "date_modified": "2021-07-13T16:00:00.000Z",
            "author": {
                "name": "Anthony Fu",
                "url": "https://antfu.me"
            }
        },
        {
            "content_html": "<p><code>async</code> / <code>await</code> in ES7 is truly a life-saver for the JavaScript world. It allows you to avoid <a href=\"http://callbackhell.com/\">callback hell</a> in your code and make it more readable. However, a common pitfall is that when you <code>await</code> a huge asynchronous task that takes very long time, it blocks the following code and could potentially make your app slow.</p>\n<p>For example:</p>\n<pre><code class=\"language-ts\">const app = await createServer()\nconst middlewareA = await resolveMiddlewareA()\nconst middlewareB = await resolveMiddlewareB()\n\napp.use(middlewareA)\napp.use(middlewareB)\n</code></pre>\n<p>We have used three <code>await</code> in the example, while the three async function does not actually relying on each other, having them sequentially we are possibility wasted some time of the operations that could be parallelized (IO, Network, etc.)</p>\n<p>So we can use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\"><code>Promise.all</code></a> to optimize the code:</p>\n<pre><code class=\"language-ts\">const [app, middlewareA, middlewareB] = await Promise.all(\n  [\n    createServer(),\n    resolveMiddlewareA(),\n    resolveMiddlewareB(),\n  ]\n)\n\napp.use(middlewareA)\napp.use(middlewareB)\n</code></pre>\n<p>In another example, you might relying on the async result, but sometime not that urgent:</p>\n<pre><code class=\"language-ts\">async function createPlugin() {\n  const toolkit = await initToolKit()\n\n  return {\n    onHookA() {\n      toolkit.invokeA()\n    },\n    onHookB() {\n      toolkit.invokeB()\n    }\n  }\n}\n\nconst plugin = await createPlugin()\n</code></pre>\n<p>Even though you don't need <code>toolkit</code> immediately, you are still forced to use <code>async function</code> because the <code>initToolKit</code> is async. To avoid this, we could make the promise been resolved in the hooks instead</p>\n<pre><code class=\"language-ts\">function createPlugin() {\n  const toolkitPromise = initToolKit()\n\n  return {\n    async onHookA() {\n      let toolkit = await toolkitPromise\n      toolkit.invokeA()\n    },\n    async onHookB() {\n      let toolkit = await toolkitPromise\n      toolkit.invokeB()\n    }\n  }\n}\n\n// now it's sync!\nconst plugin = createPlugin()\n</code></pre>\n<p>Since a Promise could only <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#description\">be resolved once</a>, using multiple <code>await</code> for a single Promise instance is <a href=\"https://blog.ashleygrant.com/2020/04/30/resolved-javascript-promises-can-be-used-multiple-times/\">totally fine</a> - it will return the resolved result immediate if the Promise is allready settled.</p>\n<p>To be more generalized, we could have an utility function like:</p>\n<pre><code class=\"language-ts\">export function createSingletonPromise&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;) {\n  let _promise: Promise&lt;T&gt; | undefined\n\n  return () =&gt; {\n    if (!_promise)\n      _promise = fn()\n    return _promise\n  }\n}\n</code></pre>\n<p>This function is also available in my utilities collection <a href=\"https://github.com/antfu/utils\"><code>@antfu/utils</code></a></p>\n",
            "url": "https://antfu.me/notes#optimize-await",
            "title": "Optimize Await",
            "date_modified": "2021-06-30T16:00:00.000Z",
            "author": {
                "name": "Anthony Fu",
                "url": "https://antfu.me"
            }
        },
        {
            "content_html": "<p>I didn't know that you can type <code>provide()</code> and <code>inject()</code> elegantly until I watched <a href=\"https://github.com/LinusBorg/\">Thorsten Lünborg</a>'s talk on <a href=\"https://vuejs.amsterdam/\">Vue Amsterdam</a>.</p>\n<p>The basic idea here is the Vue offers a type utility <code>InjectionKey</code> will you can type a Symbol to hold the type of your injection values. And when you use <code>provide()</code> and <code>inject()</code> with that symbol, it can infer the type of provider and return value automatically.</p>\n<p>For example:</p>\n<pre><code class=\"language-ts\">// context.ts\nimport { InjectionKey } from 'vue'\n\nexport interface UserInfo {\n  id: number\n  name: string\n}\n\nexport const InjectKeyUser: InjectionKey&lt;UserInfo&gt; = Symbol()\n</code></pre>\n<pre><code class=\"language-ts\">// parent.vue\nimport { provide } from 'vue' \nimport { InjectKeyUser } from './context'\n\nexport default {\n  setup() {\n    provide(InjectKeyUser, {\n      id: '117', // type error: should be number\n      name: 'Anthony'\n    })\n  }\n}\n</code></pre>\n<pre><code class=\"language-ts\">// child.vue\nimport { inject } from 'vue' \nimport { InjectKeyUser } from './context'\n\nexport default {\n  setup() {\n    const user = inject(InjectKeyUser) // UserInfo | undefined\n\n    if (user) {\n      console.log(user.name) // Anthony\n    }\n  }\n}\n</code></pre>\n<p>See <a href=\"https://v3.vuejs.org/api/composition-api.html#provide-inject\">the docs</a> for more details.</p>\n",
            "url": "https://antfu.me/notes#typed-provide-and-inject-in-vue",
            "title": "Typed `provide` and `inject` in Vue",
            "date_modified": "2021-03-04T16:00:00.000Z",
            "author": {
                "name": "Anthony Fu",
                "url": "https://antfu.me"
            }
        },
        {
            "content_html": "<p>There is currently no API to access colors of current theme in VS Code Extensions, nor the meta information of them. It frustrated me for a long while, until today I came up with a dirty but working solution.</p>\n<p>Since most of the themes follow the conversions of having <code>Light</code> or <code>Dark</code> in their names. Then we can have:</p>\n<pre><code class=\"language-ts\">import { workspace } from 'vscode'\n\nexport function isDarkTheme() {\n  const theme = workspace.getConfiguration()\n    .get('workbench.colorTheme', '')\n\n  // must be dark\n  if (theme.match(/dark|black/i) != null)\n    return true\n\n  // must be light\n  if (theme.match(/light/i) != null)\n    return false\n\n  // IDK, maybe dark\n  return true\n}\n</code></pre>\n<p>Simple, but surprisingly, it works really well. This is used for my <a href=\"https://github.com/antfu/vscode-browse-lite\">Browse Lite</a> extension to inject the preferred color schema matching with VS Code's theme. And also <a href=\"https://github.com/antfu/vscode-iconify\">Iconify IntelliSense for VS Code</a> to update icons color with the theme.</p>\n",
            "url": "https://antfu.me/notes#color-scheme-for-vs-code-extensions",
            "title": "Color Scheme for VS Code Extensions",
            "date_modified": "2021-02-28T16:00:00.000Z",
            "author": {
                "name": "Anthony Fu",
                "url": "https://antfu.me"
            }
        },
        {
            "content_html": "<p>Configurations can be quite complex, and sometimes you may want to utilize the great type checking that TypeScript provided. Change your <code>xxx.config.js</code> to <code>xxx.config.ts</code> is not an ideal solutions as you will need to have a Node.js register involved to transpile it into JavaScript and some tools might not support doing that way. Fortunately, TypeScript also support type check in plain JavaScript file with JSDoc. Here is an example of Webpack config with type checks:</p>\n<pre><code class=\"language-ts\">// webpack.config.js\n// @ts-check\n\n/**\n * @type {import('webpack').Configuration}\n */\nconst config = {\n  /*...*/\n}\n\nmodule.exports = config\n</code></pre>\n<p>Prefect. Everything should work and you can already call it a day.</p>\n<p>I have never thought about we can do better, until I saw <a href=\"https://vitejs.dev/config/#config-intellisense\">Vite's approach</a>. In Vite, you can simply have:</p>\n<pre><code class=\"language-ts\">// vite.config.js\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  /*...*/\n})\n</code></pre>\n<p>No JSDocs, no need to declare a variable first then export it. And since TypeScript will infer the types even you are using plain JavaScript, it works great with both.</p>\n<p>How? The <code>defineConfig</code> is literally a pass-through, but brings with types:</p>\n<pre><code class=\"language-ts\">import { UserConfig } from 'vite'\n\nexport function defineConfig(options: UserConfig) {\n  return options\n}\n</code></pre>\n<p><code>defineConfig</code> exists in the runtime, so it works for JavaScript even if the types get truncated. This is really just some small details of DX, but I would wish more tools could adapt this approach and make the type checking more approachable and simpler.</p>\n",
            "url": "https://antfu.me/notes#type-your-config",
            "title": "Type Your Config",
            "date_modified": "2021-02-28T16:00:00.000Z",
            "author": {
                "name": "Anthony Fu",
                "url": "https://antfu.me"
            }
        },
        {
            "content_html": "<p>In JavaScript, single quotes('') and double quotes(&quot;&quot;) are interchangeable. With ES6, we now even have backticks(``) for template literals. When you want to write a quick script to find all the strings without introducing a heavy parser, you may think about using RegExp. For example, you can have:</p>\n<pre><code class=\"language-ts\">/['&quot;`](.*?)['&quot;`]/gm\n</code></pre>\n<p>It works for most of the case, but not for mixed quotes:</p>\n<pre><code class=\"language-ts\">`const a = &quot;Hi, I'm Anthony&quot;`.match(/['&quot;`](.*)['&quot;`]/m)[1] // &quot;Hi, I&quot;\n</code></pre>\n<p>You have to make sure the starting quote and ending quote are the same type. Initially I thought it was impossible to do it in RegExp, or we have to do like this:</p>\n<pre><code class=\"language-ts\">/'(.*?)'|&quot;(.*?)&quot;|`(.*?)`/gm\n</code></pre>\n<p>That's definitely a bad idea as it makes you duplicated your notations. Until I found this solution:</p>\n<pre><code class=\"language-ts\">/(['&quot;`])(.*?)\\1/gm\n</code></pre>\n<p><code>\\1</code> is a <a href=\"https://www.regular-expressions.info/backref.html\">Backreferences</a> to your first group, similarly you can have <code>\\2</code> for the second group 2 and <code>\\3</code> for the third, you got the idea. This is exactly what I need! Take it a bit further, to exclude the backslash escaping, now we can have a much reliable RegExp for extracting quoted texts from any code.</p>\n<pre><code class=\"language-ts\">/([&quot;'`])((?:\\\\\\1|(?:(?!\\1)|\\n|\\r).)*?)\\1/mg\n</code></pre>\n<p>You can find it running in action on my <a href=\"https://github.com/windicss/vite-plugin-windicss/blob/571c1d9d9bcbf699038614e6f9fab0ddc62b959b/packages/plugin-utils/src/regexes.ts#L1\"><code>vite-plugin-windicss</code></a>.</p>\n",
            "url": "https://antfu.me/notes#match-quotes-in-pairs",
            "title": "Match Quotes in Pairs",
            "date_modified": "2021-02-27T16:00:00.000Z",
            "author": {
                "name": "Anthony Fu",
                "url": "https://antfu.me"
            }
        },
        {
            "content_html": "<p>When you need to detect if a string contains Chinese characters, you would commonly think about doing it will RegExp, or grab a ready-to-use package on npm.</p>\n<p>If you Google it, you are likely end up with <a href=\"https://stackoverflow.com/a/21113538\">this solution</a>:</p>\n<pre><code class=\"language-ts\">/[\\u4E00-\\u9FCC\\u3400-\\u4DB5\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\ud840-\\ud868][\\udc00-\\udfff]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|[\\ud86a-\\ud86c][\\udc00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d]/\n</code></pre>\n<p>It works, but a bit dirty. Fortunately, I found <a href=\"https://stackoverflow.com/a/61151122\">a much simpler solution</a> today:</p>\n<pre><code class=\"language-ts\">/\\p{Script=Han}/u\n</code></pre>\n<pre><code class=\"language-ts\">!!'你好'.match(/\\p{Script=Han}/u) // true\n</code></pre>\n<p>It's called <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes\">Unicode property escapes</a> and already available in <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#browser_compatibility\">Chrome 64, Firefox 79, Safari 11.1 and Node.js 10</a>.</p>\n<p><a href=\"https://www.regular-expressions.info/unicode.html\">All available scripts here</a>.</p>\n",
            "url": "https://antfu.me/notes#match-chinese-characters",
            "title": "Match Chinese Characters",
            "date_modified": "2021-02-24T16:00:00.000Z",
            "author": {
                "name": "Anthony Fu",
                "url": "https://antfu.me"
            }
        },
        {
            "content_html": "<p>On <a href=\"https://netlify.com\">Netlify</a>, you can setup multiple domains for a site. When you add a custom domain, the <code>xxx.netlify.app</code> is still accessible. Which would potentially cause some confusion to users. In that way, you can setup the redirection in your <code>netlify.toml</code> file, for example:</p>\n<pre><code class=\"language-toml\">[[redirects]]\n  from = &quot;https://vueuse.netlify.app/*&quot;\n  to = &quot;https://vueuse.org/:splat&quot;\n  status = 301\n  force = true\n</code></pre>\n<ul>\n<li><code>*</code> and <code>:splat</code> mean it will redirect all the sub routes as-is to the new domain.</li>\n<li><code>force = true</code> specifying it will always redirect even if the request page exists.</li>\n</ul>\n",
            "url": "https://antfu.me/notes#netlify-redirects-domains",
            "title": "Netlify Redirects (Domains)",
            "date_modified": "2021-02-19T16:00:00.000Z",
            "author": {
                "name": "Anthony Fu",
                "url": "https://antfu.me"
            }
        },
        {
            "content_html": "<p>Unlike domain redirection, sometimes you would need to rename the Netlify subdomain name (a.k.a site name), for example <code>xxx.netlify.app</code> to <code>yyy.netlify.app</code>. After you do the rename, people visiting <code>xxx.netlify.app</code> will receive a 404. And since you no longer have controls over <code>xxx.netlify.app</code>, you can't just setup a redirect in your new site.</p>\n<p>A solution here is to create a new site with your original name <code>xxx</code> and upload the redirection rules. In this case, we can have <code>netlify.toml</code> like this:</p>\n<pre><code class=\"language-toml\">[[redirects]]\n  from = &quot;*&quot;\n  to = &quot;https://yyy.netlify.app/:splat&quot;\n  status = 301\n  force = true\n</code></pre>\n<p>Note you don't have to link a repo to that, Netlify offers a great feature that <a href=\"https://app.netlify.com/drop\">let you drag and drop for static files and serve as a site</a>. So you can just save <code>netlify.toml</code> and upload it, rename the site to your original name. The redirection is done!</p>\n",
            "url": "https://antfu.me/notes#netlify-redirects-site-names",
            "title": "Netlify Redirects (Site names)",
            "date_modified": "2021-02-19T16:00:00.000Z",
            "author": {
                "name": "Anthony Fu",
                "url": "https://antfu.me"
            }
        }
    ]
}