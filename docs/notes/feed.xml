<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Anthony Fu's Notes</title>
        <link>https://antfu.me/notes</link>
        <description>Anthony Fu's Notes</description>
        <lastBuildDate>Fri, 03 Sep 2021 02:51:32 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <image>
            <title>Anthony Fu's Notes</title>
            <url>https://antfu.me/avatar.png</url>
            <link>https://antfu.me/notes</link>
        </image>
        <copyright>CC BY-NC-SA 4.0 2021 © Anthony Fu</copyright>
        <atom:link href="https://antfu.me/notes/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Get Package Root]]></title>
            <link>https://antfu.me/notes#get-package-root</link>
            <guid>https://antfu.me/notes#get-package-root</guid>
            <pubDate>Tue, 13 Jul 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>When you want to get the real file path of a certain package, you could use <code>require.resolve</code> to fetch the their main entry path.</p>
<pre><code class="language-bash">&gt; require.resolve('vite')
'/Users/.../node_modules/vite/dist/node/index.js'

&gt; require.resolve('windicss')
'/Users/.../node_modules/windicss/index.js'
</code></pre>
<p>However, when you want to get the root directory of the package, you will find the result of <code>require.resolve</code> could vary based on different packages' configuration.</p>
<p>A trick for this is to resolve the <code>package.json</code> instead, as the <code>package.json</code> is always located at the root of the package. Combining with <code>path.dirname</code>, you could always get the package root.</p>
<pre><code class="language-bash">&gt; path.dirname(require.resolve('vite/package.json'))
'/Users/.../node_modules/vite'
</code></pre>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Optimize Await]]></title>
            <link>https://antfu.me/notes#optimize-await</link>
            <guid>https://antfu.me/notes#optimize-await</guid>
            <pubDate>Wed, 30 Jun 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p><code>async</code> / <code>await</code> in ES7 is truly a life-saver for the JavaScript world. It allows you to avoid <a href="http://callbackhell.com/">callback hell</a> in your code and make it more readable. However, a common pitfall is that when you <code>await</code> a huge asynchronous task that takes very long time, it blocks the following code and could potentially make your app slow.</p>
<p>For example:</p>
<pre><code class="language-ts">const app = await createServer()
const middlewareA = await resolveMiddlewareA()
const middlewareB = await resolveMiddlewareB()

app.use(middlewareA)
app.use(middlewareB)
</code></pre>
<p>We have used three <code>await</code> in the example, while the three async function does not actually relying on each other, having them sequentially we are possibility wasted some time of the operations that could be parallelized (IO, Network, etc.)</p>
<p>So we can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all</code></a> to optimize the code:</p>
<pre><code class="language-ts">const [app, middlewareA, middlewareB] = await Promise.all(
  [
    createServer(),
    resolveMiddlewareA(),
    resolveMiddlewareB(),
  ]
)

app.use(middlewareA)
app.use(middlewareB)
</code></pre>
<p>In another example, you might relying on the async result, but sometime not that urgent:</p>
<pre><code class="language-ts">async function createPlugin() {
  const toolkit = await initToolKit()

  return {
    onHookA() {
      toolkit.invokeA()
    },
    onHookB() {
      toolkit.invokeB()
    }
  }
}

const plugin = await createPlugin()
</code></pre>
<p>Even though you don't need <code>toolkit</code> immediately, you are still forced to use <code>async function</code> because the <code>initToolKit</code> is async. To avoid this, we could make the promise been resolved in the hooks instead</p>
<pre><code class="language-ts">function createPlugin() {
  const toolkitPromise = initToolKit()

  return {
    async onHookA() {
      let toolkit = await toolkitPromise
      toolkit.invokeA()
    },
    async onHookB() {
      let toolkit = await toolkitPromise
      toolkit.invokeB()
    }
  }
}

// now it's sync!
const plugin = createPlugin()
</code></pre>
<p>Since a Promise could only <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#description">be resolved once</a>, using multiple <code>await</code> for a single Promise instance is <a href="https://blog.ashleygrant.com/2020/04/30/resolved-javascript-promises-can-be-used-multiple-times/">totally fine</a> - it will return the resolved result immediate if the Promise is allready settled.</p>
<p>To be more generalized, we could have an utility function like:</p>
<pre><code class="language-ts">export function createSingletonPromise&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;) {
  let _promise: Promise&lt;T&gt; | undefined

  return () =&gt; {
    if (!_promise)
      _promise = fn()
    return _promise
  }
}
</code></pre>
<p>This function is also available in my utilities collection <a href="https://github.com/antfu/utils"><code>@antfu/utils</code></a></p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Typed `provide` and `inject` in Vue]]></title>
            <link>https://antfu.me/notes#typed-provide-and-inject-in-vue</link>
            <guid>https://antfu.me/notes#typed-provide-and-inject-in-vue</guid>
            <pubDate>Thu, 04 Mar 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>I didn't know that you can type <code>provide()</code> and <code>inject()</code> elegantly until I watched <a href="https://github.com/LinusBorg/">Thorsten Lünborg</a>'s talk on <a href="https://vuejs.amsterdam/">Vue Amsterdam</a>.</p>
<p>The basic idea here is the Vue offers a type utility <code>InjectionKey</code> will you can type a Symbol to hold the type of your injection values. And when you use <code>provide()</code> and <code>inject()</code> with that symbol, it can infer the type of provider and return value automatically.</p>
<p>For example:</p>
<pre><code class="language-ts">// context.ts
import { InjectionKey } from 'vue'

export interface UserInfo {
  id: number
  name: string
}

export const InjectKeyUser: InjectionKey&lt;UserInfo&gt; = Symbol()
</code></pre>
<pre><code class="language-ts">// parent.vue
import { provide } from 'vue' 
import { InjectKeyUser } from './context'

export default {
  setup() {
    provide(InjectKeyUser, {
      id: '117', // type error: should be number
      name: 'Anthony'
    })
  }
}
</code></pre>
<pre><code class="language-ts">// child.vue
import { inject } from 'vue' 
import { InjectKeyUser } from './context'

export default {
  setup() {
    const user = inject(InjectKeyUser) // UserInfo | undefined

    if (user) {
      console.log(user.name) // Anthony
    }
  }
}
</code></pre>
<p>See <a href="https://v3.vuejs.org/api/composition-api.html#provide-inject">the docs</a> for more details.</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Color Scheme for VS Code Extensions]]></title>
            <link>https://antfu.me/notes#color-scheme-for-vs-code-extensions</link>
            <guid>https://antfu.me/notes#color-scheme-for-vs-code-extensions</guid>
            <pubDate>Sun, 28 Feb 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>There is currently no API to access colors of current theme in VS Code Extensions, nor the meta information of them. It frustrated me for a long while, until today I came up with a dirty but working solution.</p>
<p>Since most of the themes follow the conversions of having <code>Light</code> or <code>Dark</code> in their names. Then we can have:</p>
<pre><code class="language-ts">import { workspace } from 'vscode'

export function isDarkTheme() {
  const theme = workspace.getConfiguration()
    .get('workbench.colorTheme', '')

  // must be dark
  if (theme.match(/dark|black/i) != null)
    return true

  // must be light
  if (theme.match(/light/i) != null)
    return false

  // IDK, maybe dark
  return true
}
</code></pre>
<p>Simple, but surprisingly, it works really well. This is used for my <a href="https://github.com/antfu/vscode-browse-lite">Browse Lite</a> extension to inject the preferred color schema matching with VS Code's theme. And also <a href="https://github.com/antfu/vscode-iconify">Iconify IntelliSense for VS Code</a> to update icons color with the theme.</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Type Your Config]]></title>
            <link>https://antfu.me/notes#type-your-config</link>
            <guid>https://antfu.me/notes#type-your-config</guid>
            <pubDate>Sun, 28 Feb 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>Configurations can be quite complex, and sometimes you may want to utilize the great type checking that TypeScript provided. Change your <code>xxx.config.js</code> to <code>xxx.config.ts</code> is not an ideal solutions as you will need to have a Node.js register involved to transpile it into JavaScript and some tools might not support doing that way. Fortunately, TypeScript also support type check in plain JavaScript file with JSDoc. Here is an example of Webpack config with type checks:</p>
<pre><code class="language-ts">// webpack.config.js
// @ts-check

/**
 * @type {import('webpack').Configuration}
 */
const config = {
  /*...*/
}

module.exports = config
</code></pre>
<p>Prefect. Everything should work and you can already call it a day.</p>
<p>I have never thought about we can do better, until I saw <a href="https://vitejs.dev/config/#config-intellisense">Vite's approach</a>. In Vite, you can simply have:</p>
<pre><code class="language-ts">// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  /*...*/
})
</code></pre>
<p>No JSDocs, no need to declare a variable first then export it. And since TypeScript will infer the types even you are using plain JavaScript, it works great with both.</p>
<p>How? The <code>defineConfig</code> is literally a pass-through, but brings with types:</p>
<pre><code class="language-ts">import { UserConfig } from 'vite'

export function defineConfig(options: UserConfig) {
  return options
}
</code></pre>
<p><code>defineConfig</code> exists in the runtime, so it works for JavaScript even if the types get truncated. This is really just some small details of DX, but I would wish more tools could adapt this approach and make the type checking more approachable and simpler.</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Match Quotes in Pairs]]></title>
            <link>https://antfu.me/notes#match-quotes-in-pairs</link>
            <guid>https://antfu.me/notes#match-quotes-in-pairs</guid>
            <pubDate>Sat, 27 Feb 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>In JavaScript, single quotes('') and double quotes(&quot;&quot;) are interchangeable. With ES6, we now even have backticks(``) for template literals. When you want to write a quick script to find all the strings without introducing a heavy parser, you may think about using RegExp. For example, you can have:</p>
<pre><code class="language-ts">/['&quot;`](.*?)['&quot;`]/gm
</code></pre>
<p>It works for most of the case, but not for mixed quotes:</p>
<pre><code class="language-ts">`const a = &quot;Hi, I'm Anthony&quot;`.match(/['&quot;`](.*)['&quot;`]/m)[1] // &quot;Hi, I&quot;
</code></pre>
<p>You have to make sure the starting quote and ending quote are the same type. Initially I thought it was impossible to do it in RegExp, or we have to do like this:</p>
<pre><code class="language-ts">/'(.*?)'|&quot;(.*?)&quot;|`(.*?)`/gm
</code></pre>
<p>That's definitely a bad idea as it makes you duplicated your notations. Until I found this solution:</p>
<pre><code class="language-ts">/(['&quot;`])(.*?)\1/gm
</code></pre>
<p><code>\1</code> is a <a href="https://www.regular-expressions.info/backref.html">Backreferences</a> to your first group, similarly you can have <code>\2</code> for the second group 2 and <code>\3</code> for the third, you got the idea. This is exactly what I need! Take it a bit further, to exclude the backslash escaping, now we can have a much reliable RegExp for extracting quoted texts from any code.</p>
<pre><code class="language-ts">/([&quot;'`])((?:\\\1|(?:(?!\1)|\n|\r).)*?)\1/mg
</code></pre>
<p>You can find it running in action on my <a href="https://github.com/windicss/vite-plugin-windicss/blob/571c1d9d9bcbf699038614e6f9fab0ddc62b959b/packages/plugin-utils/src/regexes.ts#L1"><code>vite-plugin-windicss</code></a>.</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Match Chinese Characters]]></title>
            <link>https://antfu.me/notes#match-chinese-characters</link>
            <guid>https://antfu.me/notes#match-chinese-characters</guid>
            <pubDate>Wed, 24 Feb 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>When you need to detect if a string contains Chinese characters, you would commonly think about doing it will RegExp, or grab a ready-to-use package on npm.</p>
<p>If you Google it, you are likely end up with <a href="https://stackoverflow.com/a/21113538">this solution</a>:</p>
<pre><code class="language-ts">/[\u4E00-\u9FCC\u3400-\u4DB5\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA1F\uFA21\uFA23\uFA24\uFA27-\uFA29]|[\ud840-\ud868][\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|[\ud86a-\ud86c][\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d]/
</code></pre>
<p>It works, but a bit dirty. Fortunately, I found <a href="https://stackoverflow.com/a/61151122">a much simpler solution</a> today:</p>
<pre><code class="language-ts">/\p{Script=Han}/u
</code></pre>
<pre><code class="language-ts">!!'你好'.match(/\p{Script=Han}/u) // true
</code></pre>
<p>It's called <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes">Unicode property escapes</a> and already available in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#browser_compatibility">Chrome 64, Firefox 79, Safari 11.1 and Node.js 10</a>.</p>
<p><a href="https://www.regular-expressions.info/unicode.html">All available scripts here</a>.</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Netlify Redirects (Domains)]]></title>
            <link>https://antfu.me/notes#netlify-redirects-domains</link>
            <guid>https://antfu.me/notes#netlify-redirects-domains</guid>
            <pubDate>Fri, 19 Feb 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>On <a href="https://netlify.com">Netlify</a>, you can setup multiple domains for a site. When you add a custom domain, the <code>xxx.netlify.app</code> is still accessible. Which would potentially cause some confusion to users. In that way, you can setup the redirection in your <code>netlify.toml</code> file, for example:</p>
<pre><code class="language-toml">[[redirects]]
  from = &quot;https://vueuse.netlify.app/*&quot;
  to = &quot;https://vueuse.org/:splat&quot;
  status = 301
  force = true
</code></pre>
<ul>
<li><code>*</code> and <code>:splat</code> mean it will redirect all the sub routes as-is to the new domain.</li>
<li><code>force = true</code> specifying it will always redirect even if the request page exists.</li>
</ul>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
        <item>
            <title><![CDATA[Netlify Redirects (Site names)]]></title>
            <link>https://antfu.me/notes#netlify-redirects-site-names</link>
            <guid>https://antfu.me/notes#netlify-redirects-site-names</guid>
            <pubDate>Fri, 19 Feb 2021 16:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>Unlike domain redirection, sometimes you would need to rename the Netlify subdomain name (a.k.a site name), for example <code>xxx.netlify.app</code> to <code>yyy.netlify.app</code>. After you do the rename, people visiting <code>xxx.netlify.app</code> will receive a 404. And since you no longer have controls over <code>xxx.netlify.app</code>, you can't just setup a redirect in your new site.</p>
<p>A solution here is to create a new site with your original name <code>xxx</code> and upload the redirection rules. In this case, we can have <code>netlify.toml</code> like this:</p>
<pre><code class="language-toml">[[redirects]]
  from = &quot;*&quot;
  to = &quot;https://yyy.netlify.app/:splat&quot;
  status = 301
  force = true
</code></pre>
<p>Note you don't have to link a repo to that, Netlify offers a great feature that <a href="https://app.netlify.com/drop">let you drag and drop for static files and serve as a site</a>. So you can just save <code>netlify.toml</code> and upload it, rename the site to your original name. The redirection is done!</p>
]]></content:encoded>
            <author>hi@antfu.me (Anthony Fu)</author>
        </item>
    </channel>
</rss>