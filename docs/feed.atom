<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://antfu.me/</id>
    <title>Anthony Fu</title>
    <updated>2021-09-03T02:51:32.541Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <author>
        <name>Anthony Fu</name>
        <email>hi@antfu.me</email>
        <uri>https://antfu.me</uri>
    </author>
    <link rel="alternate" href="https://antfu.me/"/>
    <link rel="self" href="https://antfu.me/feed.atom"/>
    <subtitle>Anthony Fu' Blog</subtitle>
    <logo>https://antfu.me/avatar.png</logo>
    <icon>https://antfu.me/logo.png</icon>
    <rights>CC BY-NC-SA 4.0 2021 Â© Anthony Fu</rights>
    <entry>
        <title type="html"><![CDATA[Async with Composition API]]></title>
        <id/>
        <link/>
        <updated>2021-07-16T08:00:00.000Z</updated>
        <summary type="html"><![CDATA[Notes about the caveat when using async functions in Vue Composition API.]]></summary>
        <content type="html"><![CDATA[<p>There is a major caveat when working with asynchronous functions in Vue Composition API, that I believe many of you have ever come across. I have acknowledged it for a while from somewhere, but every time I want to have a detailed reference and share to others, I can't find it's documented anywhere. So, I am thinking about writing one, with a detailed explanation while sorting out the possible solutions for you.</p>
<ul>
<li><a href="#the-problem">The Problem</a></li>
<li><a href="#the-mechanism">The Mechanism</a></li>
<li><a href="#the-limitation">The Limitation</a></li>
<li><a href="#the-solutions">The Solutions</a></li>
</ul>
<h2>The Problem</h2>
<p>When using asynchronous <code>setup()</code>, <strong>you have to use effects and lifecycle hooks before the first <code>await</code> statement.</strong> (<a href="https://github.com/vuejs/rfcs/discussions/234">details</a>)</p>
<p>For example:</p>
<pre><code class="language-ts">import { ref, watch, onMounted, onUnmounted } from 'vue'

export default defineAsyncComponent({
  async setup() {
    const counter = ref(0)

    watch(counter, () =&gt; console.log(counter.value))

    // OK!
    onMounted(() =&gt; console.log('Mounted'))

    // the await statement
    await someAsyncFunction() // &lt;-----------

    // does NOT work!
    onUnmounted(() =&gt; console.log('Unmounted'))

    // still works, but does not auto-dispose 
    // after the component is destroyed (memory leak!)
    watch(counter, () =&gt; console.log(counter.value * 2))
  }
})
</code></pre>
<p>After the <code>await</code> statement,</p>
<p>the following functions will be <strong>limited</strong> (no auto-dispose):</p>
<ul>
<li><code>watch</code> / <code>watchEffect</code></li>
<li><code>computed</code></li>
<li><code>effect</code></li>
</ul>
<p>the following functions will <strong>not work</strong>:</p>
<ul>
<li><code>onMounted</code> / <code>onUnmounted</code> / <code>onXXX</code></li>
<li><code>provide</code> / <code>inject</code></li>
<li><code>getCurrentInstance</code></li>
<li>...</li>
</ul>
<h2>The Mechanism</h2>
<p>Let's take the <code>onMounted</code> API as an example. As we know, <code>onMounted</code> is a hook that registers a listener when the current component gets mounted. Notice that <code>onMounted</code> (along with other composition APIs) are <strong>global</strong>, for what I mean &quot;global&quot; is that it can be imported and called anywhere - there is <strong>no local context</strong> bound to it.</p>
<pre><code class="language-ts">// local: `onMounted` is a method of `component` that bound to it
component.onMounted(/* ... */)

// global: `onMounted` can be called without context
onMounted(/* ... */)
</code></pre>
<p>So, how does <code>onMounted</code> know what component is being mounted?</p>
<p>Vue takes an interesting approach to solve this. It uses an internal variable to record the current component instance. There is a simplified code:</p>
<p>When Vue mounts a component, it stores the instance in a global variable. When hooks been called inside the setup function, it will use the global variable to get the current component instance.</p>
<pre><code class="language-js">let currentInstance = null

// (pseudo code)
export function mountComponent(component) {
  const instance = createComponent(component)

  // hold the previous instance
  const prev = currentInstance

  // set the instance to global
  currentInstance = instance

  // hooks called inside the `setup()` will have
  // the `currentInstance` as the context
  component.setup() 

  // restore the previous instance
  currentInstance = prev 
}
</code></pre>
<p>A simplified <code>onMounted</code> implementation would be like:</p>
<pre><code class="language-js">// (pseudo code)
export function onMounted(fn) {
  if (!currentInstance) {
    warn(`&quot;onMounted&quot; can't be called outside of component setup()`)
    return
  }

  // bound listener to the current instance
  currentInstance.onMounted(fn)
}
</code></pre>
<p>With this approach, as long as the <code>onMounted</code> is called inside the component <code>setup()</code>, it will be able to get the instance of the current component.</p>
<h2>The Limitation</h2>
<p>So far so good, but what's wrong with asynchronous functions?</p>
<p>The implementation would work based on the fact that JavaScript is <strong>single-threaded</strong>. Single thread makes sure the following statements will be executed right next to each other, which in other words, there is no one could accidentally modify the <code>currentInstance</code> at the same time (a.k.a. it's <a href="https://stackoverflow.com/questions/52196678/what-are-atomic-operations-for-newbies">atomic</a>).</p>
<pre><code class="language-ts">currentInstance = instance
component.setup() 
currentInstance = prev 
</code></pre>
<p>The situation changes when the <code>setup()</code> is asynchronous. Whenever you <code>await</code> a promise, you can think the engine paused the works here and went to do another task. If we <code>await</code> the function, during the time period, multiple components creation will change the global variable unpredictably and end up with a mess.</p>
<pre><code class="language-ts">currentInstance = instance
await component.setup() // atomic lost
currentInstance = prev 
</code></pre>
<p>If we don't use <code>await</code> to check the instance, calling the <code>setup()</code> function will make it finish the tasks before the first <code>await</code> statement, and the rest will be executed whenever the <code>await</code> statement is resolved.</p>
<div class="grid grid-cols-2 gap-2 <sm:grid-cols-1">
<pre><code class="language-ts">async function setup() {
  console.log(1)
  await someAsyncFunction()
  console.log(2)
}

console.log(3)
setup()
console.log(4)
</code></pre>
<pre><code class="language-ts">// output:
3
1
4
(awaiting)
2
</code></pre>
</div>
<p>This means, there is no way for Vue to know when will the asynchronous part been called from the outside, so there is also no way to bound the instance to the context.</p>
<h2>The Solutions</h2>
<p>This is actually a limitation of JavaScript itself, unless we have some new proposal to open the gate on the language level, we have to live with it.</p>
<p>But to work around it, I have collected a few solutions for you to choose from based on your needs.</p>
<h3>Remember the Caveat and Avoid It</h3>
<p>This is, of course, an obvious &quot;solution&quot;. You can try to move your effect and hooks before the first <code>await</code> statement and carefully remember not to have them after that again.</p>
<p>Luckily, if you are using ESLint, you can have the <a href="https://eslint.vuejs.org/rules/no-watch-after-await.html"><code>vue/no-watch-after-await</code></a> and <a href="https://eslint.vuejs.org/rules/no-lifecycle-after-await.html"><code>vue/no-lifecycle-after-await</code></a> rules from <a href="https://eslint.vuejs.org/"><code>eslint-plugin-vue</code></a> enabled so it could warn you whenever you made some mistakes (they are enabled by default within the plugin presets).</p>
<h3>Wrap the Async Function as &quot;Reactive Sync&quot;</h3>
<p>In some situations, your logic might be relying on the data that fetched asynchronously. In this way, you could consider using the <a href="/posts/composable-vue-vueday-2021#async-to-sync">trick I have shared on VueDay 2021</a> to <strong>turn your async function into a sync reactive state</strong>.</p>
<pre><code class="language-ts">const data = await fetch('https://api.github.com/').then(r =&gt; r.json())

const user = data.user
</code></pre>
<pre><code class="language-ts">const data = ref(null)

fetch('https://api.github.com/')
  .then(r =&gt; r.json())
  .then(res =&gt; data.value = res)

const user = computed(() =&gt; data?.user)
</code></pre>
<p>This approach make the &quot;connections&quot; between your logic to resolve first, and then reactive updates when the asynchronous function get resolved and filled with data.</p>
<p>There is also some more general utilities for it from <a href="https://vueuse.org/">VueUse</a>:</p>
<h4><a href="https://vueuse.org/useAsyncState"><code>useAsyncState</code></a></h4>
<pre><code class="language-ts">import { useAsyncState } from '@vueuse/core'

const { state, ready } = useAsyncState(async () =&gt; {
  const { data } = await axios.get('https://api.github.com/')
  return { data }
})

const user = computed(() =&gt; state?.user)
</code></pre>
<h4><a href="https://vueuse.org/useFetch"><code>useFetch</code></a></h4>
<pre><code class="language-ts">import { useFetch } from '@vueuse/core'

const { data, isFetching, error } = useFetch('https://api.github.com/')

const user = computed(() =&gt; data?.user)
</code></pre>
<h3>Explicitly Bound the Instance</h3>
<p>Lifecycle hooks actually accept a second argument for setting the instance explicitly.</p>
<pre><code class="language-ts">export default defineAsyncComponent({
  async setup() {
    // get and hold the instance before `await`
    const instance = getCurrentInstance()

    await someAsyncFunction() // &lt;-----------

    onUnmounted(
      () =&gt; console.log('Unmounted'),
      instance // &lt;--- pass the instance to it
    )
  }
})
</code></pre>
<p>However, the downside is that this solution <strong>does not work</strong> with <code>watch</code> / <code>watchEffect</code> / <code>computed</code> / <code>provide</code> / <code>inject</code> as they does not accept the instance argument.</p>
<p>To get the effects work, you could use the <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md"><code>effectScope</code> API</a> in the upcoming Vue 3.2.</p>
<pre><code class="language-ts">import { effectScope } from 'vue'

export default defineAsyncComponent({
  async setup() {
    // create the scope before `await`, so it will be bond to the instance
    const scope = effectScope()

    const data = await someAsyncFunction() // &lt;-----------

    scope.run(() =&gt; {
      /* Use `computed`, `watch`, etc. ... */
    })

    // the lifecycle hooks will not be available here,
    // you will need to combine it with the previous snippet
    // to have both lifecycle hooks and effects works.
  }
})
</code></pre>
<h3>Compile-time Magic!</h3>
<p>In the recent <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0040-script-setup.md"><code>&lt;script setup&gt;</code> proposal</a> update, a new <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0040-script-setup.md#top-level-await">compile-time magic</a> is introduced.</p>
<p>The way it works is to inject a script after each <code>await</code> statement for restoring the current instance state.</p>
<pre><code class="language-html">&lt;script setup&gt;
const post = await fetch(`/api/post/1`).then((r) =&gt; r.json())
&lt;/script&gt;
</code></pre>
<pre><code class="language-js">import { withAsyncContext } from 'vue'

export default {
  async setup() {
    let __temp, __restore

    const post =
      (([__temp, __restore] = withAsyncContext(() =&gt;
        fetch(`/api/post/1`).then((r) =&gt; r.json())
      )),
      (__temp = await __temp),
      __restore(),
      __temp)

    // current instance context preserved
    // e.g. onMounted() will still work.

    return { post }
  }
}
</code></pre>
<p>With it, the async functions will <strong>just work</strong> when using with <code>&lt;script setup&gt;</code>. The only shame is it does not work outside of <code>&lt;script setup&gt;</code>.</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[About Yak Shaving]]></title>
        <id/>
        <link/>
        <updated>2021-05-19T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="/posts/about-yak-shaving-zh">ä¸­æåæ Original in Chinese</a></p>
</blockquote>
<p>I recently visited Zhihu occasionally and saw many questions about how to start open source, or how to make open source projects successful. I kinda had similar doubts for a long time, so I thought that maybe I could share some of my rough views on this.</p>
<p>If you don't know me, I am a team member of Vue, Vite, wenyan-lang, WindiCSS, Intlify, and the author of VueUse, Slidev, Type Challenges and i18n Ally. I also have some small open source tools under my personal GitHub account, you can have a look at my <a href="https://antfu.me/projects">full project list</a>. Since I started doing open source in earnest almost two years ago, even though those contributions aren't that impressive, they still managed to allow me to <a href="https://twitter.com/antfu7/status/1362676666221268995">work full-time on open source development and maintenance through sponsorships</a>.</p>
<p>Many people probably gonna tell you that the success of a project depends on opportunity, marketing, branding, or documentation, ecosystem, technical innovation, code quality, etc. All of these are indeed important, but for me, the most important thing is the motivation to start a project and the drive to do it well. For me, the best way to get the power is via Yak Shaving.</p>
<h2>Yak Shaving</h2>
<p><a href="https://americanexpress.io/yak-shaving">Yak Shaving</a> refers to a series of actions when you're working on one task and then you find another task that's not finished, you tackle that one first, and while you're working on that one, you find another task to do... and so forth, so that you stray from the work that should have been done, and end up not getting nothing finished. Here is a real-world example:</p>
<blockquote>
<p>You want to bake an apple pie, so you head to the kitchen.<br><br>
In the hallway, you notice some paint chipping on the wall.<br><br>
So you walk to the hardware store for some paint.<br><br>
On the way, you pass a bakery and stop in for a cupcake.<br><br>
While eating the cupcake, you feel a pain in your mouth. Itâs that cavity that youâve been putting off.<br><br>
You pick up your phone to call the dentist to make an appointment, but you see a notification from your friend Cher, whoâs having a party.<br><br>
You donât want to show up empty-handed, so you stop for a bottle of wineâ¦</p>
</blockquote>
<p>An example that more relevant to developers might be: You planned to write a blog today, but you found out none of the existing tools are good enough for you. Then you spend a month writing your own static website generator, but end up with the generator unfinished and forgetting about writing the blog.</p>
<p>I guess we all had similar experiences more or less. Yak Shaving usually refers to something negative, emphasizing inattentiveness or lack of clarity of purpose. But I kinda think it's also an important source of motivation for many things. When a person needs a tool, they are most motivated to solve it and make it happen. I, not coincidentally, am an obsessive Yak Shaving fan.</p>
<p>Maybe I'll share some of my stories with you to give you a better idea of what I'm trying to express:</p>
<h2>The story of how I started doing open source</h2>
<p>In my senior year of college, I went on a graduation trip to the Philippines with a group of college friends. Because of the various problems of exchanging foreign currency, an operation down to Taiwan dollars, US dollars, Philippine pesos and different exchange rates each time, making the record of public accounts and settlement very complicated. After we came back from the trip, we came up with the idea of making an app to solve this problem.</p>
<p>To make the app reach a large enough audience, multilingual internationalization is something we have to consider. As there are many foreign language departments in our college, we thought we could use our resources to get our friends to help on translating the App into multiple languages. However, it is obviously unrealistic to have foreign language students write JSON with bare hands, so we had to find something a little easier. Luckily, I found <a href="https://github.com/think2011/vscode-vue-i18n"><code>think2011/vscode-vue-i18n</code></a>, which looks great, but lacks some features we needed. So I contacted the author and got fork permission, and then, here comes the <a href="https://github.com/lokalise/i18n-ally">i18n Ally</a> project.</p>
<p>The later stage of App development coincided with the Composition API RFC of Vue 3. The new API seemed to solve many of the pain points in our development. In the spirit of experimentation, we installed the Vue 2 plugin and started to try it out. In the process of using it, we found out there are quite some functions we are commonly used, and also inspired by <a href="https://github.com/streamich/react-use"><code>react-use</code></a>, I extracted them out and made <a href="https://github.com/vueuse/vueuse">VueUse</a>.</p>
<p>Given that Vue 3 was still in Alpha at the time, and the community needs to gradually migrate from Vue 2 to Vue 3 for a long time in the future. I made VueUse intentionally as a universal library for Vue 2 and Vue 3 so that people could migrate seamlessly. The initial solution was to publish two packages for Vue 2 and 3 under different npm tags. As Vue 3 matured, more and more libraries wanted to go the same way to reduce the cost of maintaining two codebases at the same time. Then I thought, maybe I can find a general solution from VueUse, so that everyone could get benefit from it. And then, <a href="https://github.com/vueuse/vue-demi"><code>vue-demi</code></a> comes out. As a result, it also allows VueUse to publish one version that supports both Vue 2 and 3 at the same time.</p>
<p>VueUse's support for Vue 2 relies on the <a href="https://github.com/vuejs/composition-api"><code>@vue/composition-api</code></a> library, at some point, there are some inconsistencies in the plugin with the latest Vue 3 changes. Which results in VueUse's development being hampered. After a quite long time of no response to the PR from the repository, I thought I might be able to help out a bit, so I posted <a href="https://github.com/vuejs/composition-api/issues/343">an issue</a> in the repository saying I would like to volunteer myself maintaining the project. And that's also the opportunity for me to join the Vue team.</p>
<p>In the end, our App didn't work out, but I gained a lot of valuable experience solving problems and working on open source projects along the way. i18n Ally started out as a vue-i18n specific extension and now supports over 20 major frameworks, with over 60,000 downloads of VS Code. VueUse started as a simple toolset and now it becomes a GitHub Organization with 10 members and 8 ecosystem packages.</p>
<p>I could probably tell stories like these for a whole day, and behind almost every project there is such a motivation to try to solve a certain problem. After all of this harangue, the point I'm trying to make is that Yak Shaving can be a great engine for progressing when used properly.</p>
<p>And here are my methods of how to make Yak Shaving a good thing:</p>
<h2>Shave the Good Yak</h2>
<h3>Identify Problems</h3>
<p>I spent every day of my four years in college thinking if I could make an interesting open source project that everyone needed and live as a full-time open sourceror with freedom. The difference is that the four years I was thinking about how to make something that other people wanted, but later I was solving <strong>the actual problems that I encountered</strong>. As said, when you need a tool, you have the most motivation to make it. And also as a user, you know the best where the pain points and needs are. When you encounter this problem, others might have just encountered a similar one.</p>
<h3>Solve the Problem</h3>
<p>The most basic rule to start trying to solve a problem is to look for existing solutions, if the problem has been well solved, which meets your all needs, then just use it. Reinventing wheels might be a good way to learn, but since the wheels are already there, there has to be someone thinking about how to build a car, right?</p>
<p>When you find that there is no solution to the problem, or that the existing solutions don't work for you, while you have a great idea in your mind. Congratulations, you've found a great Yak.</p>
<h3>Good Enough</h3>
<p>The most important part of making Yak Shaving great is to <strong>just be good enough</strong> -- do not have too much expectation, if the idea is verified feasible, make it just good enough; if the idea does now work, don't be discouraged, just throw it away, maybe one day you can pick it back up again with new ideas. It's not necessary to be perfect at the beginning. You don't have to draw a grand blueprint or plan, you don't have to set a huge goal of how many stars or how many users - you are doing it for yourself, and make it just good enough to solve your own problems. The important thing is to not spending too much time on a single idea, and get back to what you should have been doing in time.</p>
<h3>Refine the Project</h3>
<p>As the first user of your own product, you will find a lot of things for improvement in the process of using it, go and modify it from time to time and do some improvements. If you got more time, you can add a README describing the problems you encountered and the motivation for doing the project, which may be helpful to someone who faced similar problems.</p>
<p>In the end, when using the project makes you feel that it's a pretty good idea, while you have completed the work that should have been done, you may wish to spend some time writing a document, improve the implementations, and promote a little. It's best if it has been recognized, but if not, just treat it as an exercise, and at least you've your own problems solved. If the responses went well, then someone will start to raise issues and send PRs. Which more enhancements and features coming, you will also gradually find the future direction of the project. Besides that, those changes and enhancements from the community may end up being a better solution to the problems you encountered at the beginning.</p>
<h3>Identify More Problems</h3>
<p>The way to find more problems is simple, learn more and try more. In the process of solving and improving the problem, you will likely find new problems that could potentially be solved. Issues from the community can also help you find more inspiration. Anyway, congratulations on entering the positive cycle!</p>
<h2>Wrapping Up</h2>
<p>Hopefully, this insight could give you some inspiration on solving your own problems, or making a good open source product, in one way or another.</p>
<p>I also recommend some awesome Yak Shaving masters, maybe their projects and experiences can give you some inspiration as well:</p>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a> - actively maintains 1100+ npm packages, Webpack and Babel both rely on 100+ of his packages</li>
<li><a href="https://github.com/tj">TJ Holowaychuk</a> - Author of koa, mocha, express, etc.</li>
<li><a href="https://github.com/lukeed">Luke Edwards</a> - Author of polka, uvu, klona, etc.</li>
<li><a href="https://github.com/egoist">Egoist</a> - Author of poi, cac, saber, etc.</li>
<li><a href="https://github.com/privatenumber">Hiroki Osame</a> - Author of esbuild-loader, vue-2-3, etc.</li>
</ul>
<p>Cheers, and happy hacking!</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Composable Vue - VueDay 2021]]></title>
        <id/>
        <link/>
        <updated>2021-04-28T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[Slides & transcript for my talk at VueDay 2021]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>This is the transcript of my talk <strong>Composable Vue</strong> at <a href="https://2021.vueday.it/">VueDay 2021</a></p>
<p>Slides: <a href="https://antfu.me/talks/2021-04-29">PDF</a> | <a href="https://talks.antfu.me/2021/composable-vue">SPA</a></p>
<p>Recording: <a href="https://youtu.be/IMJjP6edHd0">YouTube</a></p>
<p>Made with <Slidev class="inline"/>  <a href="https://github.com/slidevjs/slidev"><strong>Slidev</strong></a> - a slides maker for developers that I am working on recently.</p>
</blockquote>
<p>My sharing today is Composable Vue, some pattens and tips that might be able to help you writing better composable logic in Vue.</p>
<h2><a href="https://vueuse.org/">VueUse</a></h2>
<p>It all started with me made this project called VueUse, which is a collection of Vue composable utilities. Initially, I was making this to share some of the functions I wrote with Vue Composition API to be used across apps. Till now, it grows much bigger with the community, we are now an organization on GitHub with 9 team members, 8 add-ons packages for different integrations like motions and document head management. We also have more than 100 functions in the core package that work for both Vue 2 and 3. I have really appreciated all the contributors and the awesome community.</p>
<p><carbon-logo-github class="inline-block"/> <a href="https://github.com/vueuse/vueuse">vueuse/vueuse</a></p>
<p>In today's talk, I will share with you the patterns and tips that I have learned during developing VueUse and using it to make apps in Composition API.</p>
<h2>Composition API</h2>
<p>Let's have a quick look at the Composition API itself. BTW, please note today's talk will be a little bit advanced, which I would assume you already have a basic knowledge of what the Vue Composition API is. But don't worry if you don't, I believe you will still get some basic images of the methodology and you can also find the slides and transcript on my site after the talk.</p>
<h3>Ref vs Reactive <MarkerCore/></h3>
<p>Well, let's start with Ref and Reactive. I bet many of you have wondered the difference between them and which one should you choose.</p>
<p>You can think refs as variables and reactives as objects. When you do the assignment, one is assigning &quot;value&quot; while the other one is assigning properties. While the usage of them can really dependents on what you gonna use them, but if we really need to pick one from them, I'd say go with <code>ref</code> whenever you can.</p>
<p>With <code>ref</code>, you will need to use <code>.value</code> to access and assigning values, but this also gives you more explicit awareness of when you are tracking and triggering the reactivity system.</p>
<pre><code class="language-ts">import { ref } from 'vue'

let foo = 0
let bar = ref(0)

foo = 1
bar = 1 // ts-error
</code></pre>
<p>As you can see the example here, I actually got an error by accidentally assigning ref with a value, and here I can change the code to fix it.</p>
<pre><code class="language-ts">import { reactive } from 'vue'

const foo = { prop: 0 }
const bar = reactive({ prop: 0 })

foo.prop = 1
bar.prop = 1
</code></pre>
<p>On the other hand, when using <code>reactive</code> you actually can't tell the difference between a plain object and a reactive object without looking for the context, which could sometimes make the debugging a little bit harder.</p>
<p>Also note in reactive objects, there are several caveats you need to take care about. Like you can't do object destructure without <code>toRefs</code> otherwise they will lose the reactivity. And you will also need to wrap with a function when using with <code>watch</code> and so on, where <code>ref</code> does not have such limitations.</p>
<h3>Ref Auto Unwrapping <MarkerCore /></h3>
<p>When using with <code>refs</code>, a big obstacle that people facing is the annoying <code>.value</code>. But actually, in many cases, you can omit it and make your code looks cleaner.</p>
<pre><code class="language-ts">const counter = ref(0)

watch(counter, count =&gt; {
  console.log(count) // same as `counter.value`
})
</code></pre>
<p>The <code>watch</code> function accepts ref as the watch source directly, and it will return the unwrapped new value of the ref in the callback. So in this case, there is zero <code>.value</code> needed.</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;button @click=&quot;counter += 1&quot;&gt;
    Counter is {\{ counter }}
  &lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>The other one is the nature of Vue, in the template, all the refs are auto unwrapped, even assignments!</p>
<pre><code class="language-ts">import { ref, reactive } from 'vue'
const foo = ref('bar')
const data = reactive({ foo, id: 10 })
data.foo // 'bar'
</code></pre>
<p>And whenever you feel like to better work with objects, you can pass the ref into the reactive object, and when you access the property, reactive will unwrap the ref automatically for you. Changes to the original ref will also reflect to the reactive object!</p>
<h3><code>unref</code> - Oppsite of Ref <MarkerCore /></h3>
<p><code>unref</code> is another Composition API I would like to introduce. As the name <code>unref</code> sounds, it's kinda the opposite of ref. While the <code>ref()</code> function takes a value and turns it into a ref, <code>unref()</code> takes a ref and returns its value.</p>
<pre><code class="language-ts">function unref&lt;T&gt;(r: Ref&lt;T&gt; | T): T {
  return isRef(r) ? r.value : r
}
</code></pre>
<p>The interesting part of it is that if you pass a plain value to <code>unref</code> it will return the value as-is to you, you can see the implementation is basically this.</p>
<pre><code class="language-ts">import { unref, ref } from 'vue'

const foo = ref('foo')
unref(foo) // 'foo'

const bar = 'bar'
unref(bar) // 'bar'
</code></pre>
<p>This is not a big feature, but a good tip to unify your logic which I will show you soon</p>
<h2>Patterns &amp; Tips</h2>
<p>That's the tips for using ref and reactive. Here I'd like to share with you some patterns of writing composable functions.</p>
<h2>What's composable Functions</h2>
<p>So what's composable functions?</p>
<p>It's actually kind of hard to give a proper definition, but I'd think it's like sets for reusable logic to make your code better organized, and separate the concerns.</p>
<pre><code class="language-ts">export function useDark(options: UseDarkOptions = {}) {
  const preferredDark = usePreferredDark()         // &lt;--
  const store = useStorage('vueuse-dark', 'auto')  // &lt;--

  return computed&lt;boolean&gt;({
    get() {
      return store.value === 'auto'
        ? preferredDark.value
        : store.value === 'dark'
    },
    set(v) {
      store.value = v === preferredDark.value 
        ? 'auto' : v ? 'dark' : 'light'
    },
  })
}
</code></pre>
<p>Here is an example, the <code>useDark</code> function in VueUse is provided as a simple toggle to enable or disable the dark mode for apps. There are actually two variables involved, one is the system's preference and one is users' manual overrides. System preference can be got using media queries, while we would also need to use localStorage to read and store the user's preference of different modes.</p>
<DarkToggleButton/>
<p>As you can see in this code snippet, I have used two other composable functions <a href="https://vueuse.org/usePreferredDark"><code>usePreferredDark</code></a> and <a href="https://vueuse.org/useStorage"><code>useStorage</code></a>, they will return two refs that reflecting on their states. Detailed things like monitoring the media query changes, the timing to read and write the storage are left to them. And all I need to do is logically composing their relationship into a single ref.</p>
<p>You can see the full code or directly use it in VueUse with the link below.</p>
<VueUseFn name="useDark"/>
<h3>Think as &quot;Connections&quot;</h3>
<p>The first methodology I want to share today is to think as &quot;connections&quot;. Unlike hooks in React that will run on each updates, the <code>setup()</code> function in Vue only runs <strong>once</strong> on component initialization, to construct the relations between your state and logic.</p>
<p>You can think the equations in mathematics, where the left hand side and right hand side are always equal. Here we have <code>z=x^2+y^2</code>, while <code>x</code> and <code>y</code> are independent variables, and <code>z</code> is a controlled variables relying on <code>x</code> and <code>y</code>. Whenever I changed any of them, <code>z</code> will be updated accordingly (DEMO). Which is also similar to the formula in spreadsheets.</p>
<p>So in composable functions, we could think arguments are input and the returns as the output. The output should be able to reflect on input changes automatically. A bit complicated? I will walk with you on that later with examples.</p>
<h3>One Thing at a Time</h3>
<p>Another aspect is to do one thing at a time - which is the same as how you write any code. No need for me to spend too much time on this, but basically they are listed here.</p>
<ul>
<li>Extract duplicated logics into composable functions</li>
<li>Have meaningful names</li>
<li>Consistent naming conversions - <code>useXX</code> <code>createXX</code> <code>onXX</code></li>
<li>Keep function small and simple</li>
<li>&quot;Do one thing, and do it well&quot;</li>
</ul>
<p>Note it's also important to have a consistent naming conversion, like prefixed with <code>useXX</code> or <code>createXX</code> and so on to make those composable functions distinguishable from other functions.</p>
<h3>Passing Ref as Arguments</h3>
<p>Alright, let's start our first pattern today - Passing refs as arguments.</p>
<pre><code class="language-ts">function add(a: number, b: number) {
  return a + b
}
</code></pre>
<pre><code class="language-ts">let a = 1
let b = 2

let c = add(a, b) // 3
</code></pre>
<p>Here we have a plain add function that sums up the two arguments <code>a</code> and <code>b</code>. You can also see the example on the right.</p>
<pre><code class="language-ts">function add(a: Ref&lt;number&gt;, b: Ref&lt;number&gt;) {
  return computed(() =&gt; a.value + b.value)
}
</code></pre>
<pre><code class="language-ts">const a = ref(1)
const b = ref(2)

const c = add(a, b)
c.value // 3
</code></pre>
<p>And then we can make this function accepting refs, and return a computed ref with their sum. Then we can pass the refs to it as we normally would with plain values. The difference here is that the returned value is also a ref, but it will always be up-to-date with the ref <code>a</code> and <code>b</code>.</p>
<pre><code class="language-ts">function add(
  a: Ref&lt;number&gt; | number,
  b: Ref&lt;number&gt; | number
) {
  return computed(() =&gt; unref(a) + unref(b))
}
</code></pre>
<pre><code class="language-ts">const a = ref(1)

const c = add(a, 5)
c.value // 6
</code></pre>
<p>And remember the <code>unref</code> function we mentioned before? We can actually make this function more flexible, by accepting both refs and plain values. And use <code>unref</code> to get their values. We can also make the addition possible between a ref and a value.</p>
<h3>MaybeRef</h3>
<pre><code class="language-ts">type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T
</code></pre>
<p>Here is a simple TypeScript's type helper called <code>MaybeRef</code> that we have used a lot in VueUse. It's a union of generic <code>T</code> and <code>Ref&lt;T&gt;</code>.</p>
<pre><code class="language-ts">export function useTimeAgo(
  time: Date | number | string | Ref&lt;Date | number | string&gt;,
) {
  return computed(() =&gt; someFormating(unref(time)))
}
</code></pre>
<pre><code class="language-ts">import { computed, unref, Ref } from 'vue'

type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T

export function useTimeAgo(
  time: MaybeRef&lt;Date | number | string&gt;,
) {
  return computed(() =&gt; someFormating(unref(time)))
}
</code></pre>
<p>In this case, we have the function useTimeAgo that accepts a wide range of Date-like types as an argument. Normally if you want to accept refs, you would need to write them again as Ref versions. With this helper, you can make the type shorter and more readable (change code). A cool point it that this works great with <code>unref</code>, it can infer the correct type for <code>MaybeRef</code>.</p>
<h3>Make it Flexible <MarkerPattern /></h3>
<p>Think your functions like LEGO, there should have many different ways of composing them for different needs.</p>
<pre><code class="language-ts">import { useTitle } from '@vueuse/core'

const title = useTitle()

title.value = 'Hello World'
// now the page's title changed
</code></pre>
<p>Here we take <code>useTitle</code> function from VueUse as an example. Basically when you call it, you will get a special ref that binds to your page's title. Whenever you change the ref's value, the page's title will also be updated. Similarly, when the page's title changed externally, the change will also be reflect to the ref's value.</p>
<p>Looks good, right? But It creates a new ref whenever you call it. To make it more flexible, we can actually bind an existing ref, even computed!</p>
<pre><code class="language-ts">import { ref, computed } from 'vue'
import { useTitle } from '@vueuse/core'

const name = ref('Hello')
const title = computed(() =&gt; {
  return `${name.value} - World`
})

useTitle(title) // Hello - World

name.value = 'Hi' // Hi - World
</code></pre>
<p>Here you can see, I constructed a computed with a ref, when I change the source ref, the computed get re-evaluated so as the page's title.</p>
<h3><code>useTitle</code> <Marker class="text-blue-400">Case</Marker></h3>
<p>You must be wondering how could this be implemented. Let's take a look at a simplified version of it.</p>
<pre><code class="language-ts">import { ref, watch } from 'vue'
import { MaybeRef } from '@vueuse/core'

export function useTitle(
  newTitle: MaybeRef&lt;string | null | undefined&gt;
) {
  const title = ref(newTitle || document.title) // &lt;-- 1

  watch(title, (t) =&gt; { // &lt;-- 2
    if (t != null)
      document.title = t
  }, { immediate: true })

  return title
}
</code></pre>
<p>It's actually only two statements! How?</p>
<p>At the first line, unified the ref from the user, or create a new one. And on the second line, it watches the changes to the ref and sync up with page's title.</p>
<p>Emm, maybe it's a little bit hard to catch on what's happened in the first line, let me explain a bit.</p>
<VueUseFn name="useTitle"/>
<h3>Reuse Refs <MarkerCore /></h3>
<p>Here, we utilized an interesting behavior of the ref function.</p>
<p>Similar to <code>unref</code> - <code>ref</code> also checks whether the passed value is ref or not. If you passed a ref to it, it will it as-is - since it's already a ref, there is no need to make another.</p>
<pre><code class="language-ts">const foo = ref(1)   // Ref&lt;1&gt;
const bar = ref(foo) // Ref&lt;1&gt;

foo === bar // true
</code></pre>
<pre><code class="language-ts">function useFoo(foo: Ref&lt;string&gt; | string) {
  // no need!
  const bar = isRef(foo) ? foo : ref(foo)

  // they are the same
  const bar = ref(foo)

  /* ... */
}
</code></pre>
<p>This could also be extremely useful in composable functions that take <code>MaybeRef</code> as argument types.</p>
<h3><code>ref</code> / <code>undef</code></h3>
<p>Let's do a quick summary so far.</p>
<ul>
<li><code>MaybeRef&lt;T&gt;</code> works well with <code>ref</code> and <code>unref</code>.</li>
<li>Use <code>ref()</code> when you want to normalized it as a Ref.</li>
<li>Use <code>unref()</code> when you want to have the value.</li>
</ul>
<pre><code class="language-ts">type MaybeRef&lt;T&gt; = Ref&lt;T&gt; | T

function useBala&lt;T&gt;(arg: MaybeRef&lt;T&gt;) {
  const reference = ref(arg) // get the ref
  const value = unref(arg)   // get the value
}
</code></pre>
<p>We can use <code>MaybeRef</code> in arguments to make the function flexible, and use <code>ref()</code> when you want to normalized it as a Ref and use <code>unref()</code> when you want to get the value. Both of them are universal and no conditions needed.</p>
<h3>Object of Refs <MarkerPattern /></h3>
<p>Another pattern today is to use objects of refs. When you need to return multiple data entries in a composable function, consider returns an object composed by refs.</p>
<pre><code class="language-ts">import { ref, reactive } from 'vue'

function useMouse() {
  return { 
    x: ref(0),
    y: ref(0)
  }
}

const { x, y } = useMouse()
const mouse = reactive(useMouse())

mouse.x === x.value // true
</code></pre>
<p>In this way, users can have the full features of ES6 object destructure. The restructure values are refs, so the reactivity still remains, and users can also rename them, or take only partial of what they want.</p>
<p>On this other hand, it's also flexible enough when users want to use it as a single object, simply wrap it with the reactive function, the refs will get unwrapped as a property automatically.</p>
<p>That said, users can get benefits from both <code>ref </code>and <code>reactive</code> as need.</p>
<h3>Async to &quot;Sync&quot; <MarkerTips /></h3>
<p>Since we are constructing &quot;connections&quot; using Composition API, we can actually make async functions to &quot;sync&quot; by building the connections first before it resolves.</p>
<pre><code class="language-ts">const data = await fetch('https://api.github.com/').then(r =&gt; r.json())

// use data
</code></pre>
<p>Let's say we want to request some data use the <code>fetch</code> API. Normally we need to <code>await</code> the request been responded and data been parsed, before we can use the data. With Composition API, we can make the data as a ref of null, then be fulfilled later.</p>
<pre><code class="language-ts">const { data } = useFetch('https://api.github.com/').json()

const user_url = computed(() =&gt; data.value?.user_url)
</code></pre>
<p>This can make your apps take the time to handle other stuff while waiting for the data to be fetched. The idea is similar to react's stale-while-revalidate, but with much easier implementation.</p>
<h3><code>useFetch</code> <Marker class="text-blue-400">Case</Marker></h3>
<p>The implementation can be simplified down to this, all you have to do is to assign the value to <code>ref</code> when the promise got resolved.</p>
<pre><code class="language-ts">export function useFetch&lt;R&gt;(url: MaybeRef&lt;string&gt;) {
  const data = shallowRef&lt;T | undefined&gt;()
  const error = shallowRef&lt;Error | undefined&gt;()

  fetch(unref(url))
    .then(r =&gt; r.json())
    .then(r =&gt; data.value = r)
    .catch(e =&gt; error.value = e)

  return {
    data,
    error
  }
}
</code></pre>
<p>In the real world, we might also need some flags to show the current state of the request, where you can find the full code in VueUse.</p>
<VueUseFn name="useFetch"/>
<h3>Side-effects Self Cleanup <MarkerPattern /></h3>
<p><code>watch</code> and <code>computed</code> functions in Vue will stop themselves automatically along with the components unmounting. We'd recommend following the same pattern for your custom composable functions.</p>
<p>By calling the <code>onUnmounted</code> hooks inside your composable functions, you can schedule the effect clean-up logic.</p>
<pre><code class="language-ts">import { onUnmounted } from 'vue'

export function useEventListener(target: EventTarget, name: string, fn: any) {
  target.addEventListener(name, fn)

  onUnmounted(() =&gt; {
    target.removeEventListener(name, fn) // &lt;--
  })
}
</code></pre>
<p>For example, it's common to use <code>addEventListener</code> to register the handler to DOM events. When you finish the usage, you would also need to remember to unregister it using <code>removeEventListener</code>. In this case, we can have a function <code>useEventListener</code> that unregister itself along with the component so you don't need to worry about it anymore.</p>
<VueUseFn name="useEventListener"/>
<h3><code>effectScope</code> RFC <Marker class="text-purple-400">Upcoming</Marker></h3>
<p>While side-effects auto clean-up is nice, sometimes you might want to have better controls over when to do that. I drafted an RFC proposing a new API called <code>effectScope</code> to collect those effects into a single instance, that you can stop them together at the time you want. This is likely to be implemented and shipped with Vue 3.1. Check out for more details if it get you interested.</p>
<pre><code class="language-ts">// effect, computed, watch, watchEffect created inside the scope will be collected

const scope = effectScope(() =&gt; {
  const doubled = computed(() =&gt; counter.value * 2)

  watch(doubled, () =&gt; console.log(double.value))

  watchEffect(() =&gt; console.log('Count: ', double.value))
})

// dispose all effects in the scope
stop(scope)
</code></pre>
<h3>Typed Provide / Inject</h3>
<p>We have a set of new APIs called <code>provide</code> and <code>inject</code>. It's basically for sharing some context for the component's children to consume and reuse. They are two separate function, which means TypeScript can't actually infer the types for each context automatically.</p>
<p>But here we have a solution for that. Vue provided a type helper called <code>InjectionKey</code> where you can define a symbol that carries the type you want, and then it will hint <code>provide</code> and <code>inject</code> to have proper autocompletion and type checking.</p>
<pre><code class="language-ts">// context.ts
import { InjectionKey } from 'vue'

export interface UserInfo {
  id: number
  name: string
}

export const injectKeyUser: InjectionKey&lt;UserInfo&gt; = Symbol()
</code></pre>
<p>For example, here I defined an interface <code>UserInfo</code> which contains two properties. And I exported a symbol with the <code>InjectionKey</code> type.</p>
<pre><code class="language-ts">// parent.vue
import { provide } from 'vue' 
import { injectKeyUser } from './context'

export default {
  setup() {
    provide(injectKeyUser, {
      id: '7', // type error: should be number
      name: 'Anthony'
    })
  }
}
</code></pre>
<p>In usage, I can use the <code>provide</code> function to provide the data with key. Can you see here I get a type error that the id should be a number. So I can catch up the error right away before it goes to production.</p>
<pre><code class="language-ts">// child.vue
import { inject } from 'vue' 
import { injectKeyUser } from './context'

export default {
  setup() {
    const user = inject(injectKeyUser) 
    // UserInfo | undefined

    if (user)
      console.log(user.name) // Anthony
  }
}
</code></pre>
<p>And in the child component, we can use the <code>inject</code> function with the key as well. You can see it correctly infers the type <code>UserInfo</code> and so as its property.</p>
<h3>Shared State <MarkerPattern /></h3>
<p>With the flexibility of Vue's Composition API, sharing state is actually quite simple.</p>
<pre><code class="language-ts">// shared.ts
import { reactive } from 'vue'

export const state = reactive({
  foo: 1,
  bar: 'Hello'
})
</code></pre>
<p>You can declare some ref or reactive state in a js module, and import them to your components. Since they are using the same instance, the state will be just in sync.</p>
<pre><code class="language-ts">// A.vue
import { state } from './shared.ts'

state.foo += 1
</code></pre>
<pre><code class="language-ts">// B.vue
import { state } from './shared.ts'

console.log(state.foo) // 2
</code></pre>
<p>But please note this is actually not SSR compatible. In SSR your server will create a new app on each request, where this approach will keep the state persistent across multiple rendering. And normally it's not what we would expect.</p>
<h3>Shared State (SSR friendly) <MarkerPattern /></h3>
<p>Let's see if we can make a solution for it to work with SSR.</p>
<pre><code class="language-ts">export const myStateKey: InjectionKey&lt;MyState&gt; = Symbol()

export function createMyState() {
  const state = {
    /* ... */
  }

  return {
    install(app: App) {
      app.provide(myStateKey, state)
    }
  }
}

export function useMyState(): MyState {
  return inject(myStateKey)!
}
</code></pre>
<p>By using <code>provide</code> and <code>inject</code>, to share the state one the App context, which means it will be created every time when the server doing the rendering. You can see here I have two function, <code>createMyState</code> and <code>useMyState</code>. <code>createMyState</code> will returns a Vue plugin that provide the state to the App. While <code>useMyState</code> is just a wrapper of <code>inject</code> using the same key.</p>
<pre><code class="language-ts">// main.ts
const App = createApp(App)

app.use(createMyState())
</code></pre>
<pre><code class="language-ts">// A.vue

// use everywhere in your app
const state = useMyState()
</code></pre>
<p>In usage, we can create the state in the main entry and pass it to <code>app.use</code>. Then you can use the hook <code>useMyState</code> everywhere in your components.</p>
<p>If you have ever tried Vue Router v4, it actually uses a similar method to do that like <code>createRouter</code> and `useRouter.</p>
<h3>useVModel <MarkerTips /></h3>
<p>One last tip I'd like to share is a utility called <code>useVModel</code>.</p>
<pre><code class="language-ts">export function useVModel(props, name) {
  const emit = getCurrentInstance().emit

  return computed({
    get() {
      return props[name]
    },
    set(v) {
      emit(`update:${name}`, v)
    }
  })
}
</code></pre>
<p>It's just a simple wrapper to the component model to bind with <code>props</code> and <code>emit</code>. This is actually a lifesaver to me.</p>
<pre><code class="language-ts">export default defineComponent({
  setup(props) {
    const value = useVModel(props, 'value')

    return { value }
  }
})
</code></pre>
<p>We can take a look at the code, you can see we used a writable computed. When accessing the value, we forward the value of props to it, and when writing, we emit out the update event automatically so you can use just like a normal ref.</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;input v-model=&quot;value&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>Even more, we can actually bind into our children elements's <code>v-model</code> very easily.</p>
<VueUseFn name="useVModel"/>
<h2>Vue 2 &amp; 3</h2>
<p>That's all the tips and patterns I have for today.</p>
<p>As you might think those are for Vue 3 only, but actually they also applies for Vue 2!</p>
<h3><code>@vue/composition-api</code> <Marker class="text-teal-400">Lib</Marker></h3>
<p>In case you didn't know that, if you are still on Vue 2 but want to start using the Composition API, here we offered an official plugin that enables the Composition API for your Vue 2 app. Give it a try if you haven't.</p>
<p><carbon-logo-github class="inline-block"/> <a href="https://github.com/vuejs/composition-api">vuejs/composition-api</a></p>
<pre><code class="language-ts">import Vue from 'vue'
import VueCompositionAPI from '@vue/composition-api'

Vue.use(VueCompositionAPI)
</code></pre>
<pre><code class="language-ts">import { ref, reactive } from '@vue/composition-api'
</code></pre>
<h3>Vue 2.7 <Marker class="text-purple-400">Upcoming</Marker></h3>
<p>We also announced <a href="https://github.com/vuejs/rfcs/blob/ie11/active-rfcs/0000-vue3-ie11-support.md#for-those-who-absolutely-need-ie11-support">our plan for Vue 2.7</a> recently. Vue 2.7 will be the last minor version of Vue 2 with long time support for existing projects and those who still need IE 11 support. We will back-port Vue 3's new features to Vue 2.7 and migrate the <code>@vue/compositon-api</code> plugin into it. Stay tuned on that.</p>
<ul>
<li>Backport <code>@vue/composition-api</code> into Vue 2's core.</li>
<li><code>&lt;script setup&gt;</code> syntax in Single-File Components.</li>
<li>Migrate codebase to TypeScript.</li>
<li>IE11 support.</li>
<li>LTS.</li>
</ul>
<h3>Vue Demi <Marker class="text-teal-400">Lib</Marker></h3>
<p>If you are a library author want your libraries to support Vue 2 and 3 with the same codebase. You can try Vue Demi, which eases out the difference between Vue 2 and 3 and auto-detects users' environment.</p>
<p><carbon-logo-github class="inline-block"/> <a href="https://github.com/vueuse/vue-demi">vueuse/vue-demi</a></p>
<pre><code class="language-ts">// same syntax for both Vue 2 and 3
import { ref, reactive, defineComponent } from 'vue-demi'
</code></pre>
<h2>Thank you!</h2>
<p>That's all for today.</p>
<p>Due to the time limit, it's a shame that I can not share all I have learned with you. As the Vue composition API is still fairly new, I believe there are more patterns and better practices for us to found.</p>
<p>To find more information, do check out the <a href="https://github.com/vueuse">VueUse org on GitHub</a> and <a href="https://vueuse.org/add-ons.html">its awesome ecosystem</a>, and follow us on Twitter <a href="https://twitter.com/vueuse">@vueuse</a> to keep up-to-date with news and tips.</p>
<p>Thank you!</p>
<p align="center">
  <a href="https://github.com/sponsors/antfu#sponsors">
    <img src='https://cdn.jsdelivr.net/gh/antfu/static/sponsors.svg'>
  </a>
</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Develop with Vite - Vue Beijing]]></title>
        <id/>
        <link/>
        <updated>2021-03-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>This is the transcript of my talk at <a href="https://twitter.com/beijing_vue">Vue Beijing</a></p>
<p>Slides: <a href="https://antfu.me/talks/2021-03-28/en">English ver.</a> | <a href="https://antfu.me/talks/2021-03-28/zh">ä¸­æ ver.</a></p>
<p>Recording: <a href="https://www.youtube.com/watch?v=xx8gEHet6n8">YouTube (English)</a></p>
</blockquote>
<p>I guess many of you have already heard about <a href="https://github.com/vitejs/vite">Vite</a>, as the next thing replacing other bundlers like Webpack. Well, it's actually not 100% true. While we are used to &quot;Build with Webpack&quot;, and now, more precisely, we are <strong>Developing with Vite</strong>.</p>
<p>Today I am going to present you with a brief introduction to Vite, the next-generation development tools. And I believe you will find out the answer after it.</p>
<h2>What is Vite?</h2>
<p>Vite is a French word meaning fast. The initial motivation of it is that Evan You, the creator of Vue, got an idea of making a dev server with hot reload for Vue Single File Component without a bundler. And yeah, after a few days, Vite comes out.</p>
<p>With the name of fast, it has to be fast. And it is.</p>
<p>Let me show you a quick <a href="https://twitter.com/amasad/status/1355379680275128321">demonstration of how fast it is</a>. On the left-hand side, we have Create React App, and on the right we have Vite. And you can see during I am introducing to them, the Vite app is already ready and playable, while the other one just finishes installing its dependencies. In this demo, we can see we have over 4x faster boot-up speed improvement over Create React App, on the single component starter template. And actually, it's not even showing the full potential of Vite.</p>
<p>So how could Vite be so fast?</p>
<p>First, Vite is opinionated on providing better DX. It assumes that you are using modern browsers for development, so we don't need to have complex transpiling and polyfills involved. Also since your browser already understands Native ES module, we can even skip the bundling process and let the browser do it for us. We also involved with some optimizations to make it even faster, which I will go through them later.</p>
<p>We have a build mode for production powered by rollup. The difference between development and production make Vite capable of having good experiences for both of them.</p>
<h3>The Dev Server</h3>
<p>In a traditional bundle-based dev server, when we start the server, it will bundle your entire app and the server is ready only until the bundling is finished. In a large-scale app, it could take quite a lot of time.</p>
<p>Native ESM bases server, on the other hand, does need to do the bundling at all. The server is ready immediately and it will only transpile the modules of the pages you have opened on-demanded. So even you have a huge app with thousands of pages, it will be constantly fast as it only needs to transpile the modules for one page.</p>
<p>The transpling is powered by <a href="https://github.com/evanw/esbuild">esbuild</a>. It is a transpiler and bundler written in Go and build to native code. It is optimized with speed in mind and utilizes the potential of parallelism. It claims that it can be 10-100x faster than the traditional build tools.</p>
<p>With the support <a href="https://github.com/evanw/esbuild">esbuild</a>, we are able to support JSX, TypeScript out-of-the-box.</p>
<h3>Dependencies Pre-bundling</h3>
<p>Another optimization of Vite is the dependencies pre-bundling. Normally, your dependencies do not change really often unless you are upgrading them, but on the other hand, your user code can change everyday.</p>
<p>So by treating the user code and dependencies differently, we pre bundles your dependencies into a single file standard ESM that can be understood by the browser. In this way, we ease out the difference of packages shipping different js formats like <code>cjs</code> or node favored modules. It also reduced HTTP request overhead and importing waterfall.</p>
<p>And this bundling process is also powered by <a href="https://github.com/evanw/esbuild">esbuild</a>, with over 20x faster performance.</p>
<h3>Hot Module Replacement</h3>
<p>Another important part of Vite is that it has out-of-box hot module replacement support. Whenever you made a change to your code, the HMR is triggered. It's smart enough to know which modules would be affected by the changes and replace them efficiently. And we have first-party support for Vue single-file components and React Refresh.</p>
<p>As Vite is made by Evan, you may think it's only Vue. Well, initially, it was kind of true, but things are different now.</p>
<p>From Vite 2.0, it's now framework-agnostic and Vue is supported through a plugin. It also comes with a bunch of new features and improvements, for example the universal plugin system and first-class SSR. For more details, you check out the links in the slide.</p>
<p>You can use <code>npm init</code> to create the starter project with the official templates. As you can see, we have supported Vue, React, Preact, Lit Element, Svelte, and even vanilla. It's not limited to these, we will keep adding more as we go.</p>
<hr>
<h2>Powerful Plugins System</h2>
<p>Vite's plugins are compatible with Rollup plugins. This means you can use the huge amount of existing plugins from rollup on Vite.</p>
<p>You can check out <a href="https://github.com/patak-js/vite-rollup-plugins">this Vite Rollup Plugins site</a> by our team member <a href="https://github.com/patak-js">@patak-js</a>. It lists all the compatibility of popular rollup plugins with some demo and guides of how to use them.</p>
<p>We also have <a href="https://github.com/vitejs/awesome-vite">an awesome list</a> that lists Vite plugins for different ecosystems. Check it out, I believe you will find some of them useful to you.</p>
<hr>
<h2>Fresh Vue Authoring Experience</h2>
<p>I'd like to feature some Vite plugins for Vue that provide the Fresh authoring experience on creating Vue apps.</p>
<h3><a href="https://github.com/hannoeru/vite-plugin-pages"><code>vite-plugin-pages</code></a> by <a href="https://github.com/hannoeru">@hannoeru</a></h3>
<p>It provides Nuxt.js-like file base routing, with dynamic routes support that can be accessed as the props in the page component.</p>
<p>Only with 3 lines of code, you can set up this feature and use it immediately.</p>
<pre><code class="language-ts">import { createRouter } from 'vue-router'
import routes from 'virtual:generated-pages'

const router = createRouter({ routes })
</code></pre>
<p>Check <a href="https://github.com/hannoeru/vite-plugin-pages">its docs</a> for more.</p>
<h3><a href="https://github.com/hannoeru/vite-plugin-components"><code>vite-plugin-components</code></a> by <a href="https://github.com/antfu">@antfu</a></h3>
<p>In Vue, writing the name of the component four times in order to import them is kind of a pain for me. So I made this plugin to do the component auto-importing. Now you can put your components under <code>src/components</code> and then use them everywhere without needing to import them. We also have built-in support for auto importing component libraries with minimal configurations. For now, we have supported Vuetify, Ant Design Vue, Element Plus, Vant, and so on.</p>
<p>From:</p>
<pre><code class="language-html">&lt;script&gt;
import HelloWorld from './src/components/HelloWorld.vue'

export default {
  components: {
    HelloWorld
  }
}
&lt;/script&gt;

&lt;template&gt;
  &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>To:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;HelloWorld msg=&quot;Hello Vue 3.0 + Vite&quot; /&gt;
&lt;/template&gt;
</code></pre>
<h3><a href="https://github.com/hannoeru/vite-plugin-icons"><code>vite-plugin-icons</code></a> by <a href="https://github.com/antfu">@antfu</a></h3>
<p>Another one is <code>vite-plugin-icons</code>. It allows you to use icons from any icon set, for example, Material design icons and Font awesome. Which the on-demand spirit of Vite, this will only ship with the icons that you actually use. So you can say goodbye to the old-school icon font approach that downloads a huge font with all the icons that you don't actually need.</p>
<p>It also works well with the component auto importing, and you can use them like magic.</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;i-carbon-accessibility/&gt;
  &lt;i-mdi-account-box style=&quot;font-size: 2em; color: red&quot;/&gt;
&lt;/template&gt;
</code></pre>
<h3><a href="https://github.com/windicss/vite-plugin-windicss"><code>vite-plugin-windicss</code></a> by <a href="https://github.com/antfu">@antfu</a></h3>
<p>If you have ever used <a href="https://tailwindcss.com/">Tailwind CSS</a>, you must aware it's actually quite slow in the dev server as it ships all the utilities with megabytes of CSS to your client. This becomes the slowest part of my Vite app.</p>
<p>Luckily, we have a new thing called <a href="https://github.com/windicss/windicss">Windi CSS</a>, which you can think of it as the on-demand Tailwind CSS. Instead of shipping all the combinations of classes and purge them down later. It only generates the classes you actually use. Turns out it can be 20-100x faster than the traditional Tailwind. While it's on-demand, it also opens up more features like unit auto-inferring. Do check it out if you are using Tailwind.</p>
<h3>Try them all</h3>
<p>If you found them interesting and want to try it yourself, I also made a starter template call <a href="https://github.com/antfu/vitesse">Vitesse</a>, with all of them included and more features. Pull it down and check out.</p>
<p>These are only a small part of our plugins ecosystem, we have more of them available in the <a href="https://github.com/vitejs/awesome-vite">awesome list</a> do remember to check them out.</p>
<h3>Vue 2 for Vite</h3>
<p>If you are still using Vue 2, no worries, we have your covered!</p>
<p>While the official Vue plugin is for Vue 3. Another Vite team member <a href="http://github.com/underfin">@underfin</a> made the plugin <a href="https://github.com/underfin/vite-plugin-vue2"><code>vite-plugin-vue2</code></a> for Vue 2. With a single line in the config, you are good to go. It's been wildly adapted already, for example, <a href="https://github.com/nuxt/vite">Nuxt 2 for Vite</a> is powered on it.</p>
<p>In the <a href="https://github.com/vitejs/awesome-vite">awesome list</a>, we have marked the compatibility for each plugin of the Vue 2 support. Many of them are isomorphic to both Vue 3 and 2. If you are going to try Vue 2, you don't want to miss it.</p>
<h3>Legacy Browser Support</h3>
<p>Vite uses native ESM on both development and production, but if you want to enable legacy browsers that do not support ESM, no problem, we have it.</p>
<p>There is an official plugin <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy"><code>@vitejs/plugin-legacy</code></a> that uses Babel and System JS to transform the modules for legacy support.</p>
<pre><code class="language-ts">// vite.config.js
import legacy from '@vitejs/plugin-legacy'

export default {
  plugins: [
    legacy({
      targets: ['defaults', 'not IE 11']
    })
  ]
}
</code></pre>
<p>Check out the docs for more details.</p>
<hr>
<h2>Ecosystem and Community</h2>
<p>Then, let's talk a bit about the community.</p>
<p>I bet you already have this question - Vite is great, but what does Vite mean for the existing Vue ecosystem? Let me help you to find it out.</p>
<p>How about <a href="https://github.com/vuepress/vuepress-next">VuePress</a>? It's actually <a href="https://twitter.com/meteorlxy_cn/status/1370728812971917315">already supported Vite in the version 2 beta</a>! In v2, you can swap the engine between Webpack and Vite, and have the instant reload from Vite. Check out the docs for how it works!</p>
<p>As for Nuxt, we actually have some exciting news! The <a href="https://twitter.com/_pi0_/status/1352344462954016768">upcoming Nuxt 3 will support interchangeable engines between Webpack and Vite</a>. And you can get the benefit of the huge Nuxt community. It will be available as a public beta at Q2 this year. They also release <a href="https://twitter.com/_pi0_/status/1365049110982778884">an experimental project for Nuxt 2 to support Vite</a> where you can try it today.</p>
<p>About Vue CLI, as <a href="https://twitter.com/youyuxi/status/1354584410482499585">Evan mentioned</a>, we weren't intended to replace Vue CLI with Vite, but it turns out it could be. The long-term goal of Vue CLI is to support Vite with a powerful scaffolding capability and easier to get started.</p>
<p>We also have a community plugin <a href="https://github.com/IndexXuan/vue-cli-plugin-vite"><code>vue-cli-plugin-vite</code></a> that enables Vite support in Vue CLI that you can play with it today.</p>
<hr>
<h2>Higher-level Integrations</h2>
<p>We also have a community plugin that enables Vite support in Vue CLI that you can try today. And on top of Vite, we are now having some cool higher-level integrations tools.</p>
<p>The first one is <a href="https://github.com/vuejs/vitepress">VitePress</a>, a Vite and Vue powered static site generator. Similar to VuePress, but with more opinionated pre-configuration. This project is still experimental but already served as the generator for many official documentation sites, including the Vite docs itself.</p>
<p><a href="https://github.com/ream/ream">Ream</a> is a Vite-based framework with the support of fast SSR built-in by <a href="https://github.com/egoist">@egoist</a>. At the time I am preparing these slides, it's doing a rewrite to make not only for Vue but also for any frameworks. Stay tuned on that.</p>
<p>Edge side rendering becomes quite popular recently, and we are also having a tool called <a href="https://github.com/frandiox/vitedge">Vitedge</a> by <a href="https://github.com/frandiox">@frandiox</a> to bring it to Vite. Take a look at its repo as well.</p>
<p>Vite also supports <a href="https://vitejs.dev/guide/backend-integration.html">backend integrations</a>, now we already have <a href="https://github.com/ElMassimo/vite_ruby">Vite Ruby</a> by <a href="https://github.com/ElMassimo">@ElMassimo</a> and <a href="https://github.com/innocenzi/laravel-vite">Laravel Vite</a>by <a href="https://github.com/innocenzi">@innocenzi</a> in the community. They leverage Vite to serve the front-end and benefit from Vite's fast performance.</p>
<p>You can also set up your own backend integrations easily by following the docs below.</p>
<hr>
<h2>Upcoming</h2>
<p>Not only for Vue and the new tools. The tools you love are also going to support Vite. Here are some news for upcoming things I'd like to share with you.</p>
<p><a href="https://github.com/sveltejs/kit">Svelte Kit</a> is the next official build tools for Svelte, and <a href="https://github.com/sveltejs/kit/pull/409">they are moving from Snowpack to Vite</a>. It's in the early beta now and you can check it out if it got you interested.</p>
<p><a href="https://twitter.com/_jessicasachs/status/1354585366620221443">Cypress is also adding the first-class Vite support</a>. I believe we can see it ready within this year.</p>
<p>And <a href="https://twitter.com/storybookjs/status/1371894052015239170">Storybook is also exploring the interchangeable engines for Vite and Snowpack</a>. You can also keep an eye on that.</p>
<hr>
<h2>Start Vite today!</h2>
<p>We are waiting for you to join our community and start playing with us!</p>
<p>Just firing up this command in your terminal to get the first impressions!</p>
<pre><code class="language-bash">npm init @vitejs/app
</code></pre>
<p>That's all for today. Join the <a href="http://chat.vitejs.dev/">discord</a> to chat with us and follow us on <a href="https://twitter.com/vite_js">Twitter</a> to get the latest news.</p>
<p>See you in the community, thank you!</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reflection of Speaking in Public]]></title>
        <id/>
        <link/>
        <updated>2021-03-27T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[My sincere apologies to everyone involved.]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Disclaimer: All the words are only representing my opinions. None of them applies to the Windi CSS's author nor the team.</p>
</blockquote>
<p>The past two weeks have been tough for me. I have caused some drama where it might not need to be like that. The guilty keeps spinning around my head, asking myself if I made the right decisions, or what can be better if I am not taking it this way.</p>
<p>I guess I am still immature and naive to the community. I was so lucky to get so many of you enjoying my work, subscribing to my feeds, more than I could ever imagine. I was not aware of how the expression of myself could have so much effect on others.</p>
<p>I couldn't help myself not to think about what's the best outcome we could possibly have, if both of us could make better decisions. Maybe we can have a world that Windi and Tailwind JIT could co-exist, helping and inspiring each other, like react and preact. Windi could be the community-driven playground/experiment field to try out new ideas and ships rapidly, and Tailwind could take those good enhancements that have been proven in Windi and make it more solid and ready for production. That might be the things we should see them happen in the open-source rather than the current drama and sadness.</p>
<p>Not saying I think what Tailwind does is acceptable to me. I believe there isn't something called &quot;original ideas&quot; - we are all learning and inspiring from others. Giving proper credit to where the inspirations come from is the least thing we can do to make open source a better place and encourage more people to share their ideas/code in the public space.</p>
<p>But after these days of reflection, I think I could be more mature and calm to handle this better and prevent all of these from happening. Here are some thoughts for myself to be aware of not doing the same thing again.</p>
<ul>
<li>I should have more active communication with Adam and Tailwind on this thing before I spoke it out in public. Or even better before they make the announcement.</li>
<li>I should not take this personally and emotionally, and not assail Adam and the Tailwind team.</li>
<li>When Tailwind appended the mention in the comments, I should call it over and move on. Instead of bringing this up once again.</li>
<li>I should ask for the opinions from the Windi team before going public.</li>
</ul>
<p>I had failed to make none of these, resulting in the worst outcome. I was irresponsible to do this for both the community and the Windi team who have trusted me.</p>
<p><strong>My sincere apologies to Adam, the Tailwind team, the Windi team, and everybody involved with this drama.</strong></p>
<p>I don't know what this will end with, but fighting is definitely not something I meant to see. This drama was started by me, and I wish we can call it an end. I don't really want to see such things happening again, but I truly wish I can handle it better next time taking the lesson I have learned today. After all, I still believe people here in open source are with good willing to make things better for everyone.</p>
<p>Thank you for reading through. And hope you could understand and forgive this naive and immature boy.</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windi CSS and Tailwind JIT]]></title>
        <id/>
        <link/>
        <updated>2021-03-18T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[Wish this is the end.]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Disclaimer: All the words are only representing my opinions. None of them applies to the Windi CSS's author nor the team.</p>
</blockquote>
<Tweet>
<p lang="en" dir="ltr">Congrats Tailwind, and thanks for NOT mentioning Windi CSS at all for your new ideas.<br><br>I appreciated how did Tailwind power my apps and make my life easier. But this really changed my mind about how I see the people behind it.<br><br>Check out <a href="https://t.co/kcEzm5Ickp">https://t.co/kcEzm5Ickp</a> by <a href="https://twitter.com/satireven?ref_src=twsrc%5Etfw">@satireven</a>. <a href="https://t.co/tkJCy8Pgb3">https://t.co/tkJCy8Pgb3</a></p>&mdash; Anthony Fu (@antfu7) <a href="https://twitter.com/antfu7/status/1371533878800748545?ref_src=twsrc%5Etfw">March 15, 2021</a>
</Tweet> 
<p>I spoke out for <a href="https://github.com/windicss/windicss">Windi CSS</a> just because keeping silence on this also means we are encouraging such things to happen again in the open-source community.</p>
<p>Tailwind was once my favorite CSS framework and I was really happy to see we made it works on Vite <a href="https://twitter.com/antfu7/status/1361398324587163648">much faster</a> with <a href="https://github.com/voorjaar">@voorjaar</a>'s astonishing Windi CSS compiler. But I was totally unexpected to see that end up being like this. Don't get me wrong, it's great to see Tailwind's long pain get solved officially with Tailwind JIT and benefit the community. What I am saying is that Tailwind used/inspired by Windi's idea <strong>without even mentioning Windi CSS once and claiming it's their own ideas</strong> (until 20min after my tweets about that, <a href="https://twitter.com/adamwathan/status/1371542711086559237?s=20">they appended two tweets in the comments</a>, mentioned about Windi but still implies it's their idea. That's all we got). No official reply of this whole thing, not updates to their repo's README, at all.</p>
<p>I don't want to speculate what's the reasons or motivations behind it, all I know is that <strong>I will not use any products from Tailwind Labs anymore</strong>. If you think I was reacting too much or it was not a big deal, then I truly wish such things would never happend on you once again.</p>
<Tweet>
<p lang="en" dir="ltr">I remember the day when Windi got blown up on Twitter, <a href="https://twitter.com/adamwathan?ref_src=twsrc%5Etfw">@adamwathan</a> called me and asked me about how Windi CSS works and he is happy to make it official. And yeah, I was excited to see things are improving for the whole community, so I shared all I know with him.<br><br>1/n <a href="https://t.co/Ho1DddqA33">https://t.co/Ho1DddqA33</a></p>&mdash; Anthony Fu (@antfu7) <a href="https://twitter.com/antfu7/status/1371538602488786945?ref_src=twsrc%5Etfw">March 15, 2021</a>
</Tweet>
<Tweet>
<p lang="en" dir="ltr">It&#39;s almost impossible for a small org like us to fight with the giant Tailwind. But we will not give up just because of this.<br><br>Let&#39;s see and good luck.</p>&mdash; Anthony Fu (@antfu7) <a href="https://twitter.com/antfu7/status/1371538609388494852?ref_src=twsrc%5Etfw">March 15, 2021</a>
</Tweet>
<p>On the bright side, Windi pushed Tailwind to make the JIT and improved the DX and Tailwind forced Windi to be independent and evolving to not being a &quot;Tailwind accessory&quot; any longer.</p>
<p>There is another community based CSS-in-JS alternative called <a href="https://github.com/tw-in-js/twind">Twind</a>, which you definitely want to check out (they are working closely with Windi to bring an uniformed community standard/spec of our DSL, cheers <a href="https://github.com/sastan">@sastan</a>!).</p>
<p>As for myself, I will spend more time on working with Windi CSS to make it even better. Here is some of exciting things we are working on:</p>
<Tweet>
<p lang="en" dir="ltr">Spoiler of the new piece of our playground - interactive selector.<br><br>I always find myself trouble picking the directions of rounded corners and looking up for a huge table of all the possible combinations could be inefficient. So yeah :)<br><br>rounded-1/2 is new in Windi CSS btw ð <a href="https://t.co/f841k9BgPF">https://t.co/f841k9BgPF</a> <a href="https://t.co/pVIlB2X1nY">pic.twitter.com/pVIlB2X1nY</a></p>&mdash; Anthony Fu (@antfu7) <a href="https://twitter.com/antfu7/status/1371779599084888064?ref_src=twsrc%5Etfw">March 16, 2021</a>
</Tweet>
<Tweet>
<p lang="en" dir="ltr">Limitation? Let&#39;s break it!ð¥<br><br>Upcoming feature in <a href="https://twitter.com/windi_css?ref_src=twsrc%5Etfw">@windi_css</a> ð<br>&quot;Design in DevTools&quot;!<br><br>Whenever you made changes to the classes in DevTools, the CSS updates automatically for you, on-demand as always :)<br><br>Idea credit goes to <a href="https://twitter.com/MaximoMussini?ref_src=twsrc%5Etfw">@maximomussini</a> ð <a href="https://t.co/DHf2h5wroM">pic.twitter.com/DHf2h5wroM</a></p>&mdash; Anthony Fu (@antfu7) <a href="https://twitter.com/antfu7/status/1372244287975387145?ref_src=twsrc%5Etfw">March 17, 2021</a>
</Tweet>
<p>Thanks for reading though. Don't feel any pressure about using any tools that you needed. I choose not to use them just because my personal preference. I don't want to force anyone to switch their stack because reading this post, we will keep improve it and show you which is the better one you should use :)</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rewrite in Vite]]></title>
        <id/>
        <link/>
        <updated>2021-01-31T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[My site is now powered by Vite!]]></summary>
        <content type="html"><![CDATA[<p>The page you are looking at is now powered by <a href="https://github.com/vitejs/vite">Vite</a>. This is something I want to do for a long while since Vite came out, and it's finally done. As I have mentioned in my <a href="/posts/new-house">first blog post</a>, it was powered <a href="https://gridsome.org/">Gridsome</a> using Vue 2. With this overhaul, I can now take full advantage of Vue 3 and the <a href="https://v3.vuejs.org/guide/composition-api-introduction.html">Composition API</a> with the new <a href="https://github.com/vuejs/rfcs/pull/227"><code>&lt;script setup&gt;</code> SFC style</a>.</p>
<p>The reason for it taking me so long to do this is because I am busy (enjoy) doing <a href="https://americanexpress.io/yak-shaving">yak shaving</a>, for the tools I need to build this site.</p>
<h3>Fundamentals</h3>
<p>It begins with me trying to improve the DX using icons in <a href="/posts/journey-with-icons">this post</a>. At that time, Vue 3 just into RC, and Vite didn't reach 1.0 yet. Hearing a lot of how good Vue 3 and Vite are, I decided to give them a try on building the icon site I want to build for a long time. Since Vite is such a brand new thing, there aren't many tools/plugins out there, the ecosystem was way far from what Webpack has. I took that as a chance for me to dive deep into how Vite works while doing some contributions the ecosystem. Here is a few tools I made while building the app <a href="https://github.com/antfu/icones">IcÃ´nes</a>:</p>
<ul>
<li><a href="https://github.com/antfu/vite-plugin-components">vite-plugin-components</a> - On-demand components auto importing for Vite.</li>
<li><a href="https://github.com/antfu/vite-plugin-pwa">vite-plugin-pwa</a> - Zero-config PWA for Vite.</li>
<li><a href="https://github.com/antfu/purge-icons">vite-plugin-purge-icons</a> - Bundles icons on demand, with a Vite plugin.</li>
</ul>
<p>Also found some awesome tools form the community:</p>
<ul>
<li><a href="https://github.com/iconify/iconify">Iconify</a> - Universal icon framework, by <a href="https://github.com/cyberalien">@cyberalien</a>.</li>
<li><a href="https://github.com/brattonross/vite-plugin-voie">vite-plugin-voie</a> - File system based routing for Vite, by <a href="https://github.com/brattonross">@brattonross</a>.</li>
<li><a href="https://github.com/hannoeru/vite-plugin-pages">vite-plugin-pages</a> - Another file system based route generator, by <a href="https://github.com/hannoeru">@hannoeru</a>.</li>
</ul>
<p>With them, I got the fundamentals of a Vite project setup. Nuxt-liked file-based routing and component auto importing. I was quite satisfied with it as I could focus more on the content and logic rather than getting distracted by the routes setup and component registration.</p>
<p>I also learned <a href="https://tailwindcss.com/">Tailwind CSS</a> as a replacement of the missing UI component libraries for Vue 3. It turns out that I really enjoy Tailwind's way of rapid prototyping. As I got more control over styling things, it makes me think more about the design rather than just applying the default theme of the components library I use.</p>
<h3>Dark Mode</h3>
<p>Dark mode is supported as an experimental feature in Tailwind CSS v1.8 and shipped in v2.0. It supports two modes for you to choose from - <code>media</code> and <code>class</code>. <code>media</code> is something that works out-of-box, it changes based on users' system preference. But the limitation is that you can't toggle it manually as you want. So I went with <code>class</code> mode where I have more controls over it. But that also means I would need to implement the toggling logic myself.</p>
<p>With the power of Vue's Composition API, I am able to combine the best parts of them - reactive to the system's preference while being able to override manually.</p>
<pre><code class="language-ts">import { useStorage, usePreferredDark } from '@vueuse/core'

const preferredDark = usePreferredDark()
const colorSchema = useStorage('color-schema', 'auto')

export const isDark = computed({
  get() {
    return colorSchema.value === 'auto'
      ? preferredDark.value
      : colorSchema.value === 'dark'
  },
  set(v: boolean) {
    if (v === preferredDark.value)
      colorSchema.value = 'auto'
    else
      colorSchema.value = v ? 'dark' : 'light'
  },
})

watch(
  isDark,
  v =&gt; document.documentElement.classList.toggle('dark', v),
  { immediate: true },
)
</code></pre>
<p>Click it to try ðð¼</p>
<ToggleTheme class="text-2xl pb-2 pt-1"/>
<p>If you would like to use it in your own apps, I also extract the logic above into <a href="https://vueuse.js.org/core/usedark/"><code>useDark()</code> in VueUse</a>. Where you can simply use like this:</p>
<pre><code class="language-ts">import { useDark, useToggle } from '@vueuse/core'

const isDark = useDark()
const toggleDark = useToggle(isDark)
</code></pre>
<h3>Markdown</h3>
<p>After building IcÃ´nes, I started working on the <a href="http://codecember.ink/">Codecember</a> project with <a href="https://blog.matsu.io/about">@octref</a>, an initiative of learning and creating generative arts in December. With the spirit of dogfooding, we chosen Vite for building the site. In Codecember we will need to have a prompt every day with some texts, code snippets, and demos. This comes with the problem that Vite does not have a plugin for handling markdown files at that moment, so of course, I made one myself.</p>
<ul>
<li><a href="https://github.com/antfu/vite-plugin-md">vite-plugin-md</a> - Markdown for Vite.</li>
</ul>
<p>Basically, it uses <a href="https://markdown-it.github.io/"><code>markdown-it</code></a> to transform markdown into HTML and feed it into Vue's template compiler. As the generated template is handled by Vue, we can easily support Vue components inside Markdown.</p>
<h3>Syntax Highlighting</h3>
<p>Getting syntax highlight works in dark mode isn't an easy task as well. <a href="https://github.com/shikijs/shiki">Shiki</a> inlined all the colors into the HTML so you would not be bored by the CSS namespace pollution, but that also means it will be really hard to get the colors aware of your global color scheme. <a href="https://prismjs.com/">Prism</a> on the other hand, uses the classes combining the CSS theme to do the job. It's easier to merge two color schemes and make them aware of the <code>dark</code> trigger. The bad thing is, themes are often wrote by different authors with different styles of coloring and styling things. Sometimes, even the font and spacing could be different across different themes. If you ever ran into a similar situation, you should know what I mean. If you don't (lucky you!), see <a href="https://github.com/PrismJS/prism-themes/tree/master/themes">Prism's themes collection</a>(<a href="https://github.com/PrismJS/prism-themes/blob/c24ddffde2737293d9b2df7dc59939d527648863/themes/prism-vs.css#L9"><code>prism-vs.css</code></a> and <a href="https://github.com/PrismJS/prism-themes/blob/c24ddffde2737293d9b2df7dc59939d527648863/themes/prism-vsc-dark-plus.css#L6"><code>prism-vsc-dark-plus.css</code></a> for example).</p>
<p>Fight with them for a while you might be able to ease the misalignment eventually. But what if we can have a smarter way to do this?</p>
<ul>
<li><a href="https://github.com/antfu/prism-theme-vars">prism-theme-vars</a> - A customizable Prism.js theme using CSS variables.</li>
</ul>
<p>Instead of dealing with the lengthy CSS theme, now you can have one in less than 20 lines of CSS variables. For example:</p>
<pre><code class="language-css">@import &quot;prism-theme-vars/base.css&quot;;

:root {
  --prism-foreground: #393a34;
  --prism-background: #fbfbfb;
  --prism-comment: #b8c4b8;
  --prism-string: #c67b5d;
  --prism-literal: #3a9c9b;
  --prism-keyword: #248459;
  --prism-function: #849145;
  --prism-deleted: #a14f55;
  --prism-class: #2b91af;
  --prism-builtin: #a52727;
  --prism-property: #ad502b;
  --prism-namespace: #c96880;
  --prism-punctuation: #8e8f8b;
}
</code></pre>
<p>To have it supports dark mode is extremely simple as well:</p>
<pre><code class="language-css">html:not(.dark) {
  --prism-foreground: #393a34;
  --prism-background: #f8f8f8;
  --prism-comment: #758575;
  --prism-namespace: #444444;
  --prism-string: #bc8671;
  --prism-punctuation: #80817d;
  --prism-literal: #36acaa;
  --prism-keyword: #248459;
  --prism-function: #849145;
  --prism-deleted: #9a050f;
  --prism-class: #2b91af;
  --prism-builtin: #800000;
}

html.dark {
  --prism-foreground: #d4d4d4;
  --prism-background: #1e1e1e;
  --prism-namespace: #aaaaaa;
  --prism-comment: #758575;
  --prism-namespace: #444444;
  --prism-string: #ce9178;
  --prism-punctuation: #d4d4d4;
  --prism-literal: #36acaa;
  --prism-keyword: #38a776;
  --prism-function: #dcdcaa;
  --prism-deleted: #9a050f;
  --prism-class: #4ec9b0;
  --prism-builtin: #d16969;
}
</code></pre>
<p>That's all. You can also play with the themes in the <a href="https://prism-theme-vars.netlify.app/">Playground</a> and make some your own within 5 mins. I created my first code theme in my life using it, which is also exactly what you are looking at :)</p>
<h3>Serve-Side Generatation (SSG)</h3>
<p>While Codecember is more like a site than an app, we would need to do some server-side generation to improve our <a href="https://searchengineland.com/guide/what-is-seo">SEO</a>. Read quite a lot of code from <a href="https://github.com/vuejs/vitepress">VitePress</a>, I came up with this plugin:</p>
<ul>
<li><a href="https://github.com/antfu/vite-ssg">vite-ssg</a> - Server-side generation for Vite.</li>
</ul>
<p>The idea here is fairly simple: bundle the app entry, then for each route, dump the app using APIs from the <a href="https://github.com/vuejs/vue-next/tree/master/packages/server-renderer"><code>@vue/server-renderer</code></a> package. Simplified code here:</p>
<pre><code class="language-ts">import { renderToString } from '@vue/server-renderer'

const createApp = required('dist-ssr/app.js')

await Promise.all(
  routes.map(async(route) =&gt; {
    const { app, router, head } = createApp(false)

    router.push(route)
    await router.isReady()

    const appHTML = await renderToString(app)
    const renderedHTML = renderHTML(indexHTML, appHTML)

    await fs.writeFile(`${route}.html`, renderedHTML, 'utf-8')
  })
)
</code></pre>
<p>The full code can be found <a href="https://github.com/antfu/vite-ssg/blob/fa256449923e05e55bf15dcf4747d517bc22e33a/src/node/build.ts#L94-L104">here</a>.</p>
<p>With the <a href="https://github.com/vueuse/head">@vueuse/head</a> package made by <a href="https://github.com/egoist">@egoist</a>, I made the document head/meta manipulation in SSG with ease. Combining with <a href="https://github.com/antfu/vite-plugin-md">vite-plugin-md</a>, you can even use the frontmatter to set the meta (title, description, og:image, etc.).</p>
<pre><code class="language-html">&lt;script setup&gt;
import { useHead } from '@vueuse/head'

useHead({
  title: 'Website Title',
  meta: [
    {
      name: 'description',
      content: 'Website description',
    },
  ],
})
&lt;/script&gt;
</code></pre>
<h3>The Vite Template</h3>
<p>I found myself making small web apps frequently. Setting up plugins and configs for Vite kinda becomes the bottleneck for me to make my idea landded. So combining with those tools I am using, I made an opinionated template for myself but unexpectedly got quite some good feedback:</p>
<ul>
<li><a href="https://github.com/antfu/vitesse">Vitesse</a> - Opinionated Vite Starter Template</li>
</ul>
<h2>This Website</h2>
<p>This site is <strong>made from <a href="https://github.com/antfu/vitesse">Vitesse</a> combining with all the tools I mentioned above</strong>. To be honest, even making a static site generator right is something hard to me, not to mention that most of the hard parts are already handled by Vite. I am really happy to see so many things I have learned and crafted along the way. And glad I can make these contributions to the Vite ecosystem, that someone could find my work useful for building their apps.</p>
<h2>Thanks</h2>
<p>I can't make all these happened without the help/support from the great community, thank y'all!</p>
<p>Also want to have some special thanks to people made significant contributions towards these projects ð (A-Z)</p>
<ul>
<li><a href="https://github.com/hannoeru">@hannoeru</a></li>
<li><a href="https://github.com/matias-capeletto">@matias-capeletto</a></li>
<li><a href="https://github.com/privatenumber">@privatenumber</a></li>
<li><a href="https://github.com/sibbng">@sibbng</a></li>
</ul>
<p>Appreciation to my sponsors as well for supporting my works:</p>
<p align="center">
  <a href="https://cdn.jsdelivr.net/gh/antfu/static/sponsors.svg">
    <img src='https://cdn.jsdelivr.net/gh/antfu/static/sponsors.svg'>
  </a>
</p>
<p>And thank you for reading through!</p>
<p><strong>This site is now open sourced at <a href="https://github.com/antfu/antfu.me">antfu/antfu.me</a></strong></p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Destructuring... with object or array?]]></title>
        <id/>
        <link/>
        <updated>2020-10-21T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[Prefer object destructure or array? Can we support both?]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring</a> is a JavaScript language feature introduced in ES6 which I would assume you already familiar with it before moving on.</p>
</blockquote>
<p>We see it quite useful in many scenarios, for example, value swapping, named arguments, objects shallow merging, array slicing, etc. Today I would like to share some of my immature thoughts on &quot;destructuring&quot; in some web frameworks.</p>
<p>I am a Vue enthusiast for sure and I wrote a lot of my apps using it. And I did write React a while for my previous company <s>reluctantly</s>. As the Vue 3.0 came out recently, its exciting Composition API provides quite similar abilities for abstracting. Inspired by <a href="https://github.com/streamich/react-use">react-use</a>, I wrote a composable utility collection library early this year called <a href="https://github.com/antfu/vueuse">VueUse</a>.</p>
<p>Similar to React hooks, Vue's composable functions will take some arguments and returns some data and functions. JavaScript is just like other C-liked programming languages - only one return value is allowed. So a workaround for returning multiple values, we would commonly wrap them with an array or an object, and then destructure the returned arrays/objects. As you can already see, we are having two different philosophies here, using arrays or objects.</p>
<h2>Destructuring Arrays / Tuples</h2>
<p>In React hooks, it's a common practice to use array destructuring. For example, built-in functions:</p>
<pre><code class="language-ts">const [counter, setCounter] = useState(0)
</code></pre>
<p>Libraries for React hooks would natural pick the similar philosophy, for example <a href="https://github.com/streamich/react-use">react-use</a>:</p>
<pre><code class="language-ts">const [on, toggle] = useToggle(true)
const [value, setValue, remove] = useLocalStorage('my-key', 'foo')
</code></pre>
<p>The benefits of array destructuring is quite straightforward - you get the freedom to set the variable names with the clean looking.</p>
<h2>Destructuring Objects</h2>
<p>Instead of returning the getter and setter in React's <code>useState</code>, in Vue 3, a <code>ref</code> is created combining the getter and setter inside the single object. Naming is simpler and destructuring is no longer needed.</p>
<pre><code class="language-ts">// React
const [counter, setCounter] = useState(0)
console.log(counter)        // get
setCounter(counter + 1)     // set

// Vue 3
const counter = ref(0)
console.log(counter.value)  // get
counter.value++             // set
</code></pre>
<p>Since we don't need to rename the same thing twice for getter and setter like React does, in <a href="https://github.com/antfu/vueuse">VueUse</a>, I implemented most of the functions with object returns, like:</p>
<pre><code class="language-ts">const { x, y } = useMouse()
</code></pre>
<p>Using objects gives users more flexibility like</p>
<pre><code class="language-ts">// no destructing, clear namespace
const mouse = useMouse()

mouse.x
</code></pre>
<pre><code class="language-ts">// use only part of the value
const { y } = useMouse()
</code></pre>
<pre><code class="language-ts">// rename things
const { x: mouseX, y: mouseY } = useMouse()
</code></pre>
<p>While it's been good for different preferences and named attributes can be self-explaining, the renaming could be somehow verbose than array destructuring.</p>
<h2>Support Both</h2>
<p>What if we could support them both? Taking the advantages on each side and let users decide which style to be used to better fit their needs.</p>
<p>I did saw one library supports such usage once but I can't recall which. However, this idea buried in mind since then. And now I am going to experiment it out.</p>
<p>My assumption is that it returns an object with both behaviors of <code>array</code> and <code>object</code>. The path is clear, either to make an <code>object</code> like <code>array</code> or an <code>array</code> like <code>object</code>.</p>
<h3>Make an object behaves like an array</h3>
<p>The first possible solution comes up to my mind is to make an object behaves like an array, as you probably know, arrays are actually objects with number indexes and some prototypes. So the code would be like:</p>
<pre><code class="language-ts">const data = {
  foo: 'foo',
  bar: 'bar',
  0: 'foo',
  1: 'bar',
}

let { foo, bar } = data
let [ foo, bar ] = data // ERROR!
</code></pre>
<p>But when we destructure it as an array, it will throw out this error:</p>
<pre><code class="language-ts">Uncaught TypeError: data is not iterable
</code></pre>
<p>Before we working on how to make an object iterable, let's try the other direction first.</p>
<h3>Make an array behaves like an object</h3>
<p>Since arrays are objects, we should be able to extend it, like</p>
<pre><code class="language-ts">const data = ['foo', 'bar']
data.foo = 'foo'
data.bar = 'bar'

let [ foo, bar ] = data
let { foo, bar } = data
</code></pre>
<p>This works and we can call it a day now! However, if you are a perfectionist, you will find there is an edge case not be well covered. If we use the rest pattern to retrieve the remaining parts, the number indexes will unexpectedly be included in the rest object.</p>
<pre><code class="language-ts">let { foo, ...rest } = data
</code></pre>
<p><code>rest</code> will be:</p>
<pre><code class="language-ts">{
  bar: 'bar',
  0: 'foo',
  1: 'bar'
}
</code></pre>
<h3>Iterable Object</h3>
<p>Let's go back to our first approach to see if we can make an object iterable. And luckily, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator"><code>Symbol.iterator</code></a> is designed for the task! The document shows exactly the usage, doing some modification and we get this:</p>
<pre><code class="language-ts">const data = {
  foo: 'foo',
  bar: 'bar',
  *[Symbol.iterator]() {
    yield 'foo'
    yield 'bar'
  },
}

let { foo, bar } = data
let [ foo, bar ] = data
</code></pre>
<p>It works well but the <code>Symbol.iterator</code> will still be included in the rest pattern.</p>
<pre><code class="language-ts">let { foo, ...rest } = data

// rest
{
  bar: 'bar',
  Symbol(Symbol.iterator): Æ*
}
</code></pre>
<p>Since we are working on objects, it shouldn't be hard to make some properties not enumerable. By using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a> with <code>enumerable: false</code>:</p>
<pre><code class="language-ts">const data = {
  foo: 'foo',
  bar: 'bar',
}

Object.defineProperty(data, Symbol.iterator, {
  enumerable: false,
  value: function*() {
    yield 'foo'
    yield 'bar'
  },
})
</code></pre>
<p>Now we are successfully hiding the extra properties!</p>
<pre><code class="language-ts">let { foo, ...rest } = data

// rest
{
  bar: 'bar'
}
</code></pre>
<h2>Generator</h2>
<p>If you don't like the usage of generators, we can implement it with pure functions, following <a href="https://itnext.io/introduction-to-javascript-iterator-eac78849e0f7#:~:text=An%20iterator%20is%20an%20object,new%20iterator%20for%20each%20call">this article</a>.</p>
<pre><code class="language-ts">Object.defineProperty(clone, Symbol.iterator, {
  enumerable: false,
  value() {
    let index = 0
    let arr = [foo, bar]
    return {
      next: () =&gt; ({
        value: arr[index++],
        done: index &gt; arr.length,
      })
    }
  }
})
</code></pre>
<h2>TypeScript</h2>
<p>To me, it's meaningless if we could not get proper TypeScript support on this. Surprisingly, TypeScript support such usage almost out-of-box. Just simply use the <a href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types"><code>&amp;</code> operator</a> to make insertion of the object and array type. Destructuring will properly infer the types in both usages.</p>
<pre><code class="language-ts">type Magic = { foo: string, bar: string } &amp; [ string, string ]
</code></pre>
<h2>Take Away</h2>
<p>Finally, I made it a general function to merge arrays and objects intro the isomorphic destructurable. You can just copy the TypeScript snippet below to use it. Thanks for reading through!</p>
<blockquote>
<p>Please note this does NOT support IE11. More details: <a href="https://caniuse.com/?search=Symbol.iterator">Supported browers</a></p>
</blockquote>
<pre><code class="language-ts">function createIsomorphicDestructurable&lt;
  T extends Record&lt;string, unknown&gt;,
  A extends readonly any[]
&gt;(obj: T, arr: A): T &amp; A {

  const clone = { ...obj }

  Object.defineProperty(clone, Symbol.iterator, {
    enumerable: false,
    value() {
      let index = 0
      return {
        next: () =&gt; ({
          value: arr[index++],
          done: index &gt; arr.length,
        })
      }
    }
  })

  return clone as T &amp; A
}
</code></pre>
<h4>Usage</h4>
<pre><code class="language-ts">const foo = { name: 'foo' }
const bar: number = 1024

const obj = createIsomorphicDestructurable(
  { foo, bar } as const,
  [ foo, bar ] as const
)

let { foo, bar } = obj
let [ foo, bar ] = obj
</code></pre>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Watch with @vue/reactivity]]></title>
        <id/>
        <link/>
        <updated>2020-09-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A brief intro of how it works and a guide to implementing the (missing) `watch` on your own.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://twitter.com/antfu7/status/1298667080804233221">As you probably know</a>, the things I excited most in Vue 3 are the <a href="https://v3.vuejs.org/guide/composition-api-introduction.html">Composition API</a> and the <a href="https://v3.vuejs.org/guide/reactivity.html">reactivity system</a>. With the Composition API we can reuse logics and states across components or even apps. What's better? The underhood reactivity system is decoupled from Vue, which means you can use it almost everywhere, even without UI.</p>
<p>Here are some proof of concepts for using the reactivity system outside of Vue:</p>
<ul>
<li>
<p><a href="https://github.com/yyx990803/vue-lit"><code>@vue/lit</code></a> is a minimal framework wrote by Evan combining <a href="https://github.com/vuejs/vue-next/tree/master/packages/reactivity"><code>@vue/reactivity</code></a> and <a href="https://lit-html.polymer-project.org/"><code>lit-html</code></a>. It can run directly in browsers, with the almost identical experience as Vue Composition API.</p>
</li>
<li>
<p><a href="https://github.com/antfu/reactivue"><code>ReactiVue</code></a> ports Vue Composition API to React. It also provides React's lifecycles in the Vue style.</p>
</li>
</ul>
<p>Furthermore, you can even use Vue's libraries in them. Tested with <a href="https://github.com/antfu/vueuse"><code>VueUse</code></a> and <a href="https://github.com/posva/pinia"><code>pinia</code></a> in <a href="https://github.com/antfu/reactivue"><code>ReactiVue</code></a>, and they just work. You can find <a href="https://github.com/antfu/reactivue#using-vues-libraries">more details and examples here</a>.</p>
<p>I am also experimenting more possibility of Vue reactivity in other scenarios, for example <a href="https://twitter.com/antfu7/status/1305313110903779330?s=20">reactive file system</a>, in a project called <code>tive</code>. It's currently a WIP private repo, but keep tuned, I get more to come ð!</p>
<h2>Understanding <code>@vue/reactivity</code></h2>
<p>&quot;reactive objects&quot; returned by <code>ref()</code> or <code>reactive()</code> are actually <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a>. Those proxies will trigger some actions to track the changes on properties accessing or writing.</p>
<p>For a simplified example,</p>
<pre><code class="language-ts">const reactive = (target) =&gt; new Proxy(target, {
  get(target, prop, receiver) {
    track(target, prop)
    return Reflect.get(...arguments) // get the original data
  },
  set(target, key, value, receiver) {
    trigger(target, key)
    return Reflect.set(...arguments) // set the original data
  }
})

const obj = reactive({
  hello: 'world'
})

console.log(obj.hello) // `track()` get called
obj.hello = 'vue' // `trigger()` get called
</code></pre>
<p>So in this way, vue can be notified when those properties get accessed or when they be modified.</p>
<blockquote>
<p>For more detailed explanations, check out the <a href="https://v3.vuejs.org/guide/reactivity.html#what-is-reactivity">official docs</a></p>
</blockquote>
<h3>Computed</h3>
<p>Since we are able to know those events, we can start diving into the <code>computed</code> which is where the &quot;reactive&quot; magic start shining.</p>
<p><code>computed</code> is like a getter that auto collects the reactive dependencies source and auto re-evaluate when they get changed.</p>
<p>For example,</p>
<pre><code class="language-ts">const counter = ref(1)
const multiplier = ref(2)

const result = computed(() =&gt; counter.value * multiplier.value)

console.log(result.value) // 2
counter.value += 1
console.log(result.value) // 4
</code></pre>
<p>To know how the <code>computed</code> work, we need to dig into the lower level API <code>effect</code> first.</p>
<h2>Effect</h2>
<p><code>effect</code> is a new API introduced in Vue 3. Underneath, it's the engine powers the &quot;reactivity&quot; in <code>computed</code> and <code>watch</code>. For the most of the time, you don't need to directly use it. But knowing it well helps you understand the reactivity system much easier.</p>
<p><code>effect</code> takes the first argument as the <code>getter</code> and a second argument for the options. The <code>getter</code> is the function that collect its deps on each run via their <code>track()</code> hooks. The field <code>scheduler</code> in options provides a way to invoke a custom function when the deps change.</p>
<p>So basically, you can write a simple <code>computed</code> on your own like:</p>
<pre><code class="language-ts">const computed = (getter) =&gt; {
  let value
  let dirty = true
  
  const runner = effect(getter, {
    lazy: true,
    scheduler() {
      dirty = true // deps changed
    }
  })
  
  // return should be a `Ref` in real world, simplified here
  return {
    get value() {
      if (dirty) {
        value = runner() // re-evaluate
        dirty = false
      }
      return value
    }
  }
}
</code></pre>
<p>If you really interested in how it works in Vue, check out <a href="https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/computed.ts">the source code here</a></p>
<h2>Build yourself a <code>watch</code></h2>
<p>We have done the most important APIs in <code>@vue/reactivity</code> now, which is <code>ref</code> <code>reactive</code> <code>effect</code> <code>computed</code>.</p>
<p>Oh wait, we are missing the <code>watch</code> here!</p>
<pre><code class="language-js">import { watch } from '@vue/reactivity' // does NOT exist!
</code></pre>
<p>If you take a look at Vue 3's source code, you will find that <code>watch</code> is actually <a href="https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/apiWatch.ts">implemented in <code>@vue/runtime-core</code></a>, along with the Vue's component model and lifecycles. The main reason for this is that <code>watch</code> is deep bound with the component's lifecycles (auto dispose, invalidate, etc.). But it shouldn't be the thing to keep you from using it outside of Vue.</p>
<p>Let's implement the <code>watch</code> our own!</p>
<h3>The Basic</h3>
<p>Let's take a look at Vue's watch interface first</p>
<pre><code class="language-ts">const count = ref(0)

watch(
  () =&gt; count.value,
  (newValue) =&gt; {
    console.log(`count changed to: ${newValue}!`)
  }
)

count.value = 2
// count changed to: 2!
</code></pre>
<p>With the knowledge of <code>effect</code>, it's quite straight forward to implement</p>
<pre><code class="language-ts">const watch = (getter, fn) =&gt; {
  const runner = effect(getter, {
    lazy: true,
    scheduler: fn
  }
  
  // a callback function is returned to stop the effect
  return () =&gt; stop(runner)
}
</code></pre>
<p>Watch is lazy by default in Vue, you can add the third options to give control to the users.</p>
<h3>Watch for Ref</h3>
<p>You may also notice that the Vue's <code>watch</code> also allows passing the ref directly to it.</p>
<pre><code class="language-ts">watch(
  count,
  () =&gt; { /* onChanged */ }
)
</code></pre>
<p>For that, just wrap it into a getter will do</p>
<pre><code class="language-ts">const watch = (source, fn) =&gt; {
  const getter = isRef(source)
    ? () =&gt; source.value
    : source

  const runner = effect(getter, {
    lazy: true,
    scheduler: fn
  }

  return () =&gt; stop(runner)
}
</code></pre>
<h3>Watch Deeply</h3>
<p>One other great feature about <code>watch</code> is that it allows you to watch on deep changes.</p>
<pre><code class="language-ts">const state = reactive({
  info: {
    name: 'Anthony',
  }
})

watch(state, () =&gt; { console.log('changed!') }, { deep: true })

state.info.name = 'Anthony Fu'
// changed!
</code></pre>
<p>To implement this feature, you need to collect the <code>track()</code> events on every nested property. We can achieve that with a <code>traverse</code> function.</p>
<pre><code class="language-ts">function traverse(value, seen = new Set()) {
  if (!isObject(value) || seen.has(value))
    return value

  seen.add(value) // prevent circular reference 
  if (isArray(value)) {
    for (let i = 0; i &lt; value.length; i++)
      traverse(value[i], seen)
  }
  else {
    for (const key of Object.keys(value))
      traverse(value[key], seen)
  }
  return value
}

const watch = (source, fn, { deep, lazy = true }) =&gt; {
  let getter = isRef(source)
    ? () =&gt; source.value
    : isReactive(source) 
      ? () =&gt; source
      : source
    
  if (deep)
    getter = () =&gt; traverse(getter())
    
  const runner = effect(getter, {
    lazy,
    scheduler: fn
  }

  return () =&gt; stop(runner)
}
</code></pre>
<p>Done! The thing left to do is to polish, adding overloads to make it more flexible, add more options to get better control, and handle some edge cases. Then you should get yourself a good start for using a custom <code>watch</code>!</p>
<h2>Lifecycles</h2>
<p>In Vue, <code>computed</code> and <code>watch</code> will automatically bind their <code>effect</code> runner to the current component instance. When the component get unmounted, the effects bond to it will be auto disposed. More specially, you can read <a href="https://github.com/vuejs/vue-next/blob/985bd2bcb5fd8bccd1c15c8c5d89a6919fd73922/packages/runtime-core/src/apiWatch.ts#L294">the source code here</a>.</p>
<p>Since we don't have an instance, if you want to stop those effects, you have to do them manually. When you have multiple effects in used, to stop them together, you have to manually collect them together. One easier way is to mock similar lifecycles like Vue. This requires some amount of works, I will explain that in another blog post, please keep tuned.</p>
<h2>Take Away</h2>
<p>Thanks for reading! And hope it helpful for you to understand and better play with the Vue reactivity system. If you want to have the <code>watch</code> out side of Vue, I made one for you (much more robust than the examples above for sure).</p>
<pre class="block">
npm i <a href='https://github.com/antfu/vue-reactivity-watch' target='_blank'>@vue-reactivity/watch</a>
</pre> 
<p>Have fun ;P</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Journey with Icons]]></title>
        <id/>
        <link/>
        <updated>2020-08-16T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[To solve the pain I faced in using icons for the web, I built several tools to make the DX better.]]></summary>
        <content type="html"><![CDATA[<h3>TL;DR</h3>
<p>To solve the pain I faced in using icons for the web, I built the following tools to make the DX better.</p>
<h4>Apps</h4>
<ul>
<li><a href="https://github.com/antfu/icones">IcÃ´nes</a> - Icon Explorer with Instant Fuzzy searching</li>
<li><a href="https://github.com/antfu/vscode-iconify">Iconify IntelliSense</a> - VS Code Extension for inline icon previewing</li>
<li><a href="https://github.com/antfu/vitesse">Vitesse</a> - An Opinionated Vite Starter Template</li>
</ul>
<h4>Tools</h4>
<ul>
<li><a href="https://github.com/antfu/purge-icons">PurgeIcons</a> - Bundles icons on demand</li>
<li><a href="https://github.com/antfu/svg-packer">SVG Packer</a> - Pack SVGs to Icon Fonts - In Browser</li>
</ul>
<p>Would be nice if you are willing to give them a try. As there are still a lot of works to be done, contributions are greatly welcome :)</p>
<h2>Journey with Icons</h2>
<p>I make websites and small web-based utilities from time to time. Every time I build them, I take care of the design by myself. Amount of the different aspects, icons always play a big role to me. <a href="https://materialdesignicons.com/">Material Design Icons</a> is the icon set I used most overtime, it has an excellent design foundation from Google and a wide range of icons maintained by the community. And the most important fact is that it has a complete tooling ecosystem - svgs with js, web fonts or even being built-in supported by Vuetify. I could just plugin it in most any kind of apps with very low effort.</p>
<p>However, if you want to try some other icon sets for different looks &amp; feels, you may not be that lucky. Many awesome icon-sets only offer SVGs for download and need to be manually imported to your projects. This could be a laborious and time-consuming work, even just preview them on your apps.</p>
<p>Fortunately, I found <a href="https://iconify.design/">Iconify</a> - a unified icons framework that offers over 6,000 icons from 80+ popular icon sets with a single CDN entry and on demand loading. The usage would be something like this:</p>
<pre><code class="language-html">&lt;!--Import Framework--&gt;
&lt;script src=&quot;https://code.iconify.design/1/1.0.7/iconify.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="language-html">&lt;!--Use an icon from Font Awesome--&gt;
&lt;span class=&quot;iconify&quot; data-icon=&quot;fa:home&quot;&gt;&lt;/span&gt;

&lt;!--Use another icon from Material Design Icons--&gt;
&lt;span class=&quot;iconify&quot; data-icon=&quot;mdi:flask&quot;&gt;&lt;/span&gt;
</code></pre>
<p>It's done. You get access to all the 6,000 icons with in an unfied syntax. As it's on-demand, you can switch your icon systems whenever you want without worrying about the setup or the bundle size. It's also framework independent, which means you can use it in Vue, React, Svelte, plain html or whatever you want.</p>
<p>This looks so good and the story should be end here, however, it does have some limitations. As it's loaded on demand via web queries with its icon services, there will be a visible delay for icons to be loaded on the first page, specially when users have unstable connections to the Iconify servers. Also, you might have some logic to change icons with user interactions, Iconify will only start to request the icon when you actually rendered the id into the DOM. This causes some flickers on the icon switching which you possibly want to avoid.</p>
<p>The solution for this is quite straight forward, preloading the icons and the icon rendering could become synchronized. However, loading the entire icon set will impact your bundle size while manually picking what you used could be laborious and make it less flexible.</p>
<h3><a href="https://github.com/antfu/purge-icons">PurgeIcons</a></h3>
<p>Inspired by <a href="https://purgecss.com/">PurgeCSS</a>, I made the tool called <a href="https://github.com/antfu/purge-icons">PurgeIcons</a>. It statical analyzes your code and generates the <a href="https://docs.iconify.design/sources/bundles/">icon bundle</a> on-demand.</p>
<p><img src="https://user-images.githubusercontent.com/11247099/89781398-ce625a80-db45-11ea-86bf-d50471c526b7.gif" alt=""></p>
<p>Along with <a href="https://github.com/antfu/purge-icons/tree/master/packages/vite-plugin-purge-icons/README.md">the Vite plugin</a>, you can simplify import this inline in your app's entry, and the icons you use will be bundled into your code and load them synchronously.</p>
<pre><code class="language-ts">import { createApp } from 'vue'
import App from './App.vue'

import '@purge-icons/generated' // &lt;-- This

createApp(App).mount('#app')
</code></pre>
<p>It also provides a CLI tool and plugins for <a href="https://github.com/antfu/purge-icons/tree/main/packages/purge-icons-webpack-plugin">Webpack</a> and <a href="https://github.com/antfu/purge-icons/tree/main/packages/rollup-plugin-purge-icons">Rollup</a>. More frameworks support like Vue CLI, Nuxt, Gridsome or even plain html are coming soon.</p>
<p>With it, the tooling is kinda prefect to me now - I can use any icons without any compromise in the runtime. If you want to give it a try, I also made a pre-configured start template <a href="https://github.com/antfu/vitesse">ð Vitesse</a> with PurgeIcons built-in.</p>
<h2>Icon Searching</h2>
<p>The tooling get solved, here comes to my another pain for a long time - searching for icons.</p>
<p>I live in China, my network conditions are usually quite unstable for oversee connections. It often took me around 30 seconds to get the searching in <a href="https://materialdesignicons.com/">Material Design Icons</a> or <a href="https://iconify.design/">Iconify</a>. And for most of the time, you won't get the perfect icons on your first try. Repeating searching for multiple times with a huge delay is just killing me.</p>
<p>And so, I finally get some time and motivation to work on making one my own recently. Also considering this being a chance for me to try Vue 3 + Vite and to learn Tailwind CSS.</p>
<h3>IcÃ´nes</h3>
<p>By the power of Iconify, I can only ship with the icon IDs and leave the icon loading task to Iconify. In this way, searching could be done locally - instantly.</p>
<p><img src="https://github.com/antfu/icones/raw/master/screenshots/1.png" alt=""></p>
<p><img src="https://github.com/antfu/icones/raw/master/screenshots/2.png" alt=""></p>
<p>With Iconify's data collection, it can get access to all the 80+ icon sets within a single place.</p>
<p>I also made a small utility called <a href="https://github.com/antfu/svg-packer">SVG Packer</a> for IcÃ´nes. With it, you can select the icons you want and pack them into ready to used icon fonts.</p>
<p><img src="https://github.com/antfu/icones/raw/master/screenshots/5.png" alt=""></p>
<p><img src="https://github.com/antfu/icones/raw/master/screenshots/3.png" alt=""></p>
<blockquote>
<p>Tips: You can also copy the icons as Vue or React components</p>
</blockquote>
<p>Try it out if you haven't. A fully-offline electron version is also coming soon.</p>
<h2>Editor Support</h2>
<p>Browsing and searching for icons are good to me now. Now comes to the editor integration. It's actually kinda hard to know what the icons look like from their IDs. Auto-completion for IDs is also a good feature I would love to have.</p>
<h3><a href="https://github.com/antfu/vscode-iconify">Iconify IntelliSense</a> for VS Code</h3>
<p>With a lot of inspirations from the <a href="https://github.com/lukas-tr/vscode-materialdesignicons-intellisense">VS Code extension for MDI</a>, Iconify IntelliSense was born.</p>
<p><img src="https://github.com/antfu/vscode-iconify/raw/master/screenshots/preview-1.png" alt=""></p>
<p>Loading icon data and cache them on demand, it encoded svgs into data urls to be displayed as images in VS Code. With the <a href="https://code.visualstudio.com/api/references/vscode-api#DecorationRenderOptions">TextEditorDecoration</a> API, I achieve the feature to replace the icon IDs with the icon image itself in place. The icons will become visible and editable when you move the cursor around them.</p>
<p>Auto-completion with icon preview is also available. By typing the icon set id and the following delimiter colon <code>:</code>, a list of icons in the set will popup and you may continue type to do a simple search.</p>
<h3>Journey is not ended</h3>
<p>These apps and tools solved my long pain with icons. I can focus on bringing ideas live much more efficiently. I will call it a page for now, however, the journey is not yet ended. I am still passioning about exploring how the tooling for icons could go. And also keep polishing these tools to make them easier to use and integrate. Wish they could benefit more developers and designers, and make site building more simple and pleasant.</p>
<p>Glad if you found them useful to you as well. And thanks for reading XD.</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Make Libraries Working with Vue 2 and 3]]></title>
        <id/>
        <link/>
        <updated>2020-07-01T14:00:00.000Z</updated>
        <summary type="html"><![CDATA[Try Vue Demi!]]></summary>
        <content type="html"><![CDATA[<p>Today, Evan has announced that the first RC of Vue 3 <a href="https://github.com/vuejs/rfcs/issues/183">will be released in mid-July</a>. The post suggests library/plugin authors to start migrating the support for Vue 3. But as the APIs and behaviors have changed a lot, is that possible to make our libraries support Vue 2 and 3 at the same time?</p>
<h2>Universal Code</h2>
<p>The most simple way is to write universal code that works in both versions without any additional modification, just like people would do for <a href="https://python-future.org/compatible_idioms.html">Python 2 and 3</a>. Simple does not mean it's easy. Write such components requires you to avoid <strong>things that newly introduced in Vue 3</strong> and <strong>things that deprecated from Vue 2</strong>. In other words, you can't use:</p>
<ul>
<li>Composition API</li>
<li><code>.sync</code> <code>.native</code> modifiers</li>
<li>Filters</li>
<li><a href="/posts/vue-3-notes#-use-markraw-for-vendor-objects">3rd-parties vendor objects</a></li>
<li>etc. (let me know if I missed anything and I will update the list)</li>
</ul>
<p>This just makes life harder and you can't benefit from the new awesome APIs in Vue 3.</p>
<h2>Use Branches</h2>
<p><a href="https://github.com/vuejs/rfcs/issues/183#issuecomment-652134760">A reply</a> to <a href="https://github.com/vuejs/rfcs/issues/183#issuecomment-651944231">this problem</a> from a core team member suggests using different branches to separate your support for each targeting version. I think it's a good solution for existing and mature libraries as their codebases are usually more stable and version targeting optimization might require them to have better code isolations.</p>
<p>The drawback of this is that you will need to maintain two codebases which double your workload. For small scale libraries or new libraries that want to support both versions, doing bugfix or feature supplements twice is just no ideal. I would not recommend using this approach at the very beginning of your projects.</p>
<h2>Build Scripts</h2>
<p>In <a href="https://github.com/antfu/vueuse">VueUse</a>, I wrote <a href="https://github.com/antfu/vueuse/tree/master/scripts">some build scripts</a> to make the code imports from the target version's API while building. After that, I would need to publish two tags <code>vue2</code> <code>vue3</code> to distinguish different version supports. With this, I can wite the code once and make the library supports both Vue versions. The problem of it is that I need to build twice on each release and guide users to install with the corresponding plugin version (and manually install <a href="https://github.com/vuejs/composition-api"><code>@vue/composition-api</code></a> for Vue 2).</p>
<hr>
<p>It has been several months since I wrote VueUse. During this period, I am always trying to figure out a proper way to extract the logic from VueUse, so it can be reused and benefit other library authors. But after all, I still think it's just too complicated to be used in general.</p>
<p>However, at the moment I started to write this post, I came up with the idea - providing the universal interface for both versions. If it works, in this way, authors are no need to worried about the users' environments anymore.</p>
<p>And after some experiments...</p>
<h2>ð© Introducing <a href="https://github.com/antfu/vue-demi">Vue Demi</a></h2>
<p><a href="https://github.com/antfu/vue-demi"><strong>Vue Demi</strong></a> is a developing utility that allows you to write Universal Vue Libraries for Vue 2 and 3. Without worrying about users' installed versions.</p>
<p>When you are going to create a Vue plugin/library, simply install <code>vue-demi</code> as your dependency and import anything related to Vue from it. Publish your plugin/library as usual, your package would become universal!</p>
<pre><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;vue-demi&quot;: &quot;latest&quot;
  }
}
</code></pre>
<pre><code class="language-ts">import Vue, { ref, reactive } from 'vue-demi'
</code></pre>
<p>Underhood, it utilized the <a href="https://docs.npmjs.com/misc/scripts"><code>postinstall</code> npm hook</a>. After all packages get installed, <a href="https://github.com/antfu/vue-demi/blob/master/scripts/postinstall.js">the script</a> will start to check the installed Vue version and redirect the exports to based on the local Vue version. When working with Vue 2, it will also install <code>@vue/composition-api</code> automatically if it doesn't get installed.</p>
<p>You can also check <a href="https://github.com/antfu/vue-demi/tree/master/examples">the working examples</a>, where I created a demo library <a href="https://github.com/antfu/vue-demi/blob/master/examples/%40vue-demi/use-mouse/src/index.ts"><code>@vue-demi/use-mouse</code></a> with just a single file entry.</p>
<p>Please keep in mind that Vue Demi is experimental and there will definitely be some glitches. Feel free to give it a try and let me know if anything goes wrong.</p>
<p>Thanks and happy hacking!</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 3 Migration Notes]]></title>
        <id/>
        <link/>
        <updated>2020-07-01T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Note: This is my personal notes/tips for migrating to Vue 3 and will be updated overtime. Please refer to <a href="https://v3.vuejs.org">the official docs</a> for the complete changelog.</p>
</blockquote>
<p>Sorted by the importance of my personal sense.</p>
<h3>ð« use <code>markRaw</code> for vendor objects</h3>
<p>The new reactivity system proxied the object passed to the Vue context. For vendor objects or class instances, you need to wrap it with <code>markRaw</code> in order to disable the reactivity injection.</p>
<pre><code class="language-ts">// works in Vue 2
this.codemirror = CodeMirror.fromTextArea(el)

// in Vue 3 you need to use markRaw()
// otherwise the CodeMirror won't work as expected
this.codemirror = markRaw(CodeMirror.fromTextArea(el))
</code></pre>
<p>I think this is a pretty tricky one. You won't see any warn or error on initialization, but the internal state of the vendor object might be messed up. You might face errors that comes from the libraries while couldn't find out why (the example above took me one hour of debugging to find out).</p>
<h3>ð« <code>.sync</code> â <code>v-model:</code></h3>
<p><code>.sync</code> modifier is unified by <code>v-model:</code></p>
<pre><code class="language-html">&lt;!-- Vue 2 --&gt;
&lt;Component name.sync=&quot;name&quot;/&gt;

&lt;!-- Vue 3 --&gt;
&lt;Component v-model:name=&quot;name&quot;/&gt;
</code></pre>
<p><code>v-model</code> on native element would be <code>value/input</code> while on custom components, it changed to <code>modelValue</code> and <code>update:modelValue</code></p>
<h3>ð« <code>shims-vue.d.ts</code></h3>
<blockquote>
<p>Update: now you can use <a href="https://github.com/znck/vue-developer-experience/tree/master/packages/typescript-plugin-vue"><code>@vuedx/typescript-plugin-vue</code></a> for better type inference with SFC (no need for <code>shims-vue.d.ts</code> then)</p>
</blockquote>
<p>Changed to this:</p>
<pre><code class="language-ts">declare module '*.vue' {
  import { defineComponent } from 'vue';
  const Component: ReturnType&lt;typeof defineComponent&gt;;
  export default Component;
}
</code></pre>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Type Inferencing in Vue]]></title>
        <id/>
        <link/>
        <updated>2020-06-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>As you may or may not know, I am working on preparing to release the v1.0 version for <a href="https://github.com/vuejs/composition-api">@vue/composition-api</a> recently. One of the current problems is that the type inference does not play well, <a href="https://github.com/vuejs/composition-api/issues/338">#338</a>. So I get a chance to have a deeper look at <a href="https://github.com/vuejs/composition-api">vue-next</a>'s type implementations. I will tell you what I learned and how the magic works in Vue.</p>
<p>Forget about the <code>setup()</code> function and <code>Composition API</code> for now, let talk about the options API in Vue 2 that everybody familiar with. In a classical example, we would have <code>data</code>, <code>computed</code>, <code>methods</code> and some other fields like this:</p>
<pre><code class="language-js">export default {
  data: {
    first_name: &quot;Anthony&quot;,
    last_name: &quot;Fu&quot;,
  },
  computed: {
    full_name() {
      return this.first_name + &quot; &quot; + this.last_name;
    },
  },
  methods: {
    hi() {
      alert(this.full_name);
    },
  },
};
</code></pre>
<p>It works well in Javascript and putting all the context into <code>this</code> is pretty straight forward and easy to understand. But when you switch to TypeScript for static type checking. <code>this</code> will not be the context you expected. How can we make the types work for Vue like the example above?</p>
<h2>Type for <code>this</code></h2>
<p>To explicitly assign type to <code>this</code>, we can simpily use the <code>this parameter</code>:</p>
<pre><code class="language-ts">interface Context {
  $injected: string
}

function bar(this: Context, a: number) {
  this.$injected // ok
}
</code></pre>
<p>The limitation of this approach is that we will lose the methods signature when working with a dict of methods:</p>
<pre><code class="language-ts">type Methods = Record&lt;string, (this: Context, ...args:any[]) =&gt; any&gt;

const methods: Methods = {
  bar(a: number) {
    this.$injected // ok
  }
}

methods.bar('foo', 'bar') // no error, the type of arguments becomes `any[]`
</code></pre>
<p>We would not want to ask users to explicitly type <code>this</code> in every methods in order to make the type checking works.<br>
So we will need another approach.</p>
<h3><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#thistypet"><code>ThisType&lt;T&gt;</code></a></h3>
<p>After digging into the Vue's code, I found an interesting TypeScirpt utility <code>ThisType&lt;T&gt;</code>. The official doc says:</p>
<blockquote>
<p>This utility does not return a transformed type. Instead, it serves as a marker for a contextual <code>this</code> type.</p>
</blockquote>
<p><code>ThisType</code> would affect all the nested functions. With it, we can have:</p>
<pre><code class="language-ts">type Methods = {
  double: (a: number) =&gt; number
  deep: {
    nested: {
      half: (a: number) =&gt; number
    }
  }
}

const methods: Methods &amp; ThisType&lt;Methods &amp; Context&gt; = {
  double(a: number) {
    this.$injected // ok
    return a * 2
  },
  deep: {
    nested: {
      half(a: number) {
        this.$injected // ok
        return a / 2
      }
    }
  }
}

methods.double(2) // ok
methods.double('foo') // error
methods.deep.nested.half(4) // ok
</code></pre>
<p>The typing works well, but it still requires users to define the type interface of Methods first. Can we make it infers itself automatically?</p>
<p>We can do that with function inference:</p>
<pre><code class="language-ts">type Options&lt;T&gt; = {
  methods?: T 
} &amp; ThisType&lt;T &amp; Context&gt;

function define&lt;T&gt;(options: Options&lt;T&gt;) {
  return options
}

define({
  methods: {
    foo() {
      this.$injected // ok
    },
  },
})
</code></pre>
<blockquote>
<p>The inference graph would be like</p>
<p>TODO: draw a graph</p>
</blockquote>
<p>Cool. There is only one step left, to make context object dynamic inference from <code>data</code> and <code>computed</code>.</p>
<p>The full working demo would be:</p>
<pre><code class="language-ts">/* ---- Type ---- */
export type ExtractComputedReturns&lt;T extends any&gt; = {
  [key in keyof T]: T[key] extends (...args: any[]) =&gt; infer TReturn
    ? TReturn
    : never
}

type Options&lt;D = {}, C = {}, M = {}&gt; = {
  data: () =&gt; D
  computed: C
  methods: M
  mounted: () =&gt; void
  // and other options
} 
&amp; ThisType&lt;D &amp; M &amp; ExtractComputedReturns&lt;C&gt;&gt; // merge them together

function define&lt;D, C, M&gt;(options: Options&lt;D, C, M&gt;) {}

/* ---- Usage ---- */
define({
  data() {
    return {
      first_name: &quot;Anthony&quot;,
      last_name: &quot;Fu&quot;,
    }
  },
  computed: {
    fullname() {
      return this.first_name + &quot; &quot; + this.last_name
    },
  },
  methods: {
    notify(msg: string) {
      alert(msg)
    }
  },
  mounted() {
    this.notify(this.fullname)
  },
})
</code></pre>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Domain Email]]></title>
        <id/>
        <link/>
        <updated>2020-06-17T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>Saw <a href="https://twitter.com/youyuxi/status/1272932071749619712">a tweet from Evan You</a> about the <a href="https://hey.com/">hey.com</a> mail service recently. I got interested in having a short and nice email address. My current one in Hotmail is just too long to even being spell out in talk. <code>hey.com</code> looks very nice but $99/year is not a very good deal to me. I decide to use my own domain for receiving emails.</p>
<p>I did this a couple years ago for another domain, I kinda remember an open-source tool allowing forwarding emails by just adding DNS record. I took some time to search for it but I didn't find the page matches with my memory. I went GitHub to search in my stared projects, it turns out the tool now becomes and Freemium SaaS <a href="https://forwardemail.net/">forwardemail.net</a> with a fresh new logo and website design that I can't even recognize it.</p>
<p>The DNS forwarding feature just works the same, but it requires you to log in and register your domain now. I am glad it now being more well documented and charging for premium supports which can help it sustain.</p>
<p>The config is quite simple as usual, just 3 DNS record:</p>
<pre><code class="language-html">MX   @  mx1.forwardemail.net  10
MX   @  mx2.forwardemail.net  20
TXT  @  forward-email=youremail@example.com
</code></pre>
<p>Thatâs it! It also provides some advanced configs, you can check <a href="https://forwardemail.net/en/faq">the doc here</a>.</p>
<p>While setting up and reading the docs, I learned that you can explicitly purge the cache for <a href="https://1.1.1.1/purge-cache/">Cloudflare DNS</a> and <a href="https://developers.google.com/speed/public-dns/cache">Google DNS</a>. That's a very good-to-know tip!</p>
<p>And now, you can say hi to me at <a href="mailto:hi@antfu.me">hi@antfu.me</a>!</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[New House]]></title>
        <id/>
        <link/>
        <updated>2020-06-12T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>I always feel that I need a blog but I never have one.</p>
<p>So I took some time to rewrite my homepage and adding the blog section. and Hi, here I am :)</p>
<p>This time I gave a try on <a href="http://gridsome.org/">Gridsome</a> and it works petty well. I do love the <code>&lt;static-query&gt;</code> custom block that works even in components. The <a href="https://gridsome.org/docs/images/">progressive image</a> also solves my years of pain in making a photography portfolio (and I have never finished one).</p>
<p>While I was browsing Gridsome's starter templates, I found a great website <a href="https://forestry.io/">Forestry.io</a>. It's a Git-backed CMS that I can write and manage my blog posts in a nice GUI website and then commit back to Github. This is the feature that I wish to have for a long time, did not expect to see such a well built and nicely designed service out there.</p>
<p>As for the blog, I am likely to do some bilingual stuff in the future. Some posts will be written in English, some might be in Chinese. A switch button will be shown then. Also planned to post my photos in this site, which I would need to implement the gallery page for it.</p>
<p>The site is still WIP, if you have any thoughts or suggestions, please tell me via <a href="mailto:hi@antfu.me">email</a> or on <a href="https://twitter.com/antfu7">Twitter</a>. Thanks!</p>
<p>:)</p>
]]></content>
        <author>
            <name>Anthony Fu</name>
            <email>hi@antfu.me</email>
            <uri>https://antfu.me</uri>
        </author>
    </entry>
</feed>