import{_ as e}from"./Blog.vue_vue&type=script&setup=true&lang.39d150f4.js";import{l as n,o as l,m as t,h as a,a as r,k as u}from"./vendor.14139df1.js";import"./app.108283c1.js";const i=r("div",{class:"prose m-auto"},[r("h2",{id:"归纳",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#归纳","aria-hidden":"true"},"#"),u(" 归纳")]),r("ol",null,[r("li",null,"压缩 HTML 等文本文件是传输大文件最基本的方法；"),r("li",null,"分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段“Content-Range”，响应状态码必须是 206；"),r("li",null,"也可以一次请求多个范围，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。"),r("li",null,"要注意这四种方法不是互斥的，而是可以混合起来使用，例如压缩后再分块传输，或者分段后再分块，实验环境的 URI“/16-3”就模拟了后一种的情形，你可以自己用 Telnet 试一下。")]),r("h2",{id:"分块传输",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#分块传输","aria-hidden":"true"},"#"),u(" 分块传输")]),r("p",null,"“化整为零”的思路在 HTTP 协议里就是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。"),r("p",null,"“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。"),r("p",null,"下面我们来看一下分块传输的编码规则，其实也很简单，同样采用了明文的方式，很类似响应头。"),r("ol",null,[r("li",null,"每个分块包含两个部分，长度头和数据块；"),r("li",null,"长度头是以 CRLF（回车换行，即\\r\\n）结尾的一行明文，用 16 进制数字表示长度；"),r("li",null,"数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；"),r("li",null,"最后用一个长度为 0 的块表示结束，即“0\\r\\n\\r\\n”。")]),r("p",null,[r("img",{src:"https://static001.geekbang.org/resource/image/25/10/25e7b09cf8cb4eaebba42b4598192410.png",alt:""})]),r("h2",{id:"范围请求",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#范围请求","aria-hidden":"true"},"#"),u(" 范围请求")]),r("ol",null,[r("li",null,"请求头")]),r("ul",null,[r("li",null,[r("p",null,"Range 是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围。")]),r("li",null,[r("p",null,"要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。")])]),r("ol",{start:"2"},[r("li",null,"响应头")]),r("ul",null,[r("li",null,"Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。")]),r("h2",{id:"多段数据",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#多段数据","aria-hidden":"true"},"#"),u(" 多段数据")]),r("p",null,"这种情况需要使用一种特殊的 MIME 类型：“multipart/byteranges”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“boundary=xxx”给出段之间的分隔标记。"),r("p",null,[r("img",{src:"https://static001.geekbang.org/resource/image/ff/37/fffa3a65e367c496428f3c0c4dac8a37.png",alt:""})])],-1),o={setup(r,{expose:u}){const o={title:"16 | 把大象装进冰箱：HTTP传输大文件的方法",date:"2021-10-24T16:00:00.000Z",duration:"10min",meta:[{property:"og:title",content:"16 | 把大象装进冰箱：HTTP传输大文件的方法"}]};u({frontmatter:o});return n({title:"16 | 把大象装进冰箱：HTTP传输大文件的方法",meta:[{property:"og:title",content:"16 | 把大象装进冰箱：HTTP传输大文件的方法"}]}),(n,r)=>{const u=e;return l(),t(u,{frontmatter:o},{default:a((()=>[i])),_:1})}}};export{o as default};
